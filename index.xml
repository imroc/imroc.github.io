<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>roc的个人网站</title>
    <link>/</link>
      <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <description>roc的个人网站</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><copyright>roc © 2021</copyright><lastBuildDate>Wed, 25 Nov 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url>
      <title>roc的个人网站</title>
      <link>/</link>
    </image>
    
    <item>
      <title>Kubernetes 学习笔记</title>
      <link>/note/learning-kubernetes/</link>
      <pubDate>Thu, 23 Jan 2020 00:00:00 +0000</pubDate>
      <guid>/note/learning-kubernetes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>TKE 学习笔记</title>
      <link>/note/learning-tke/</link>
      <pubDate>Fri, 24 Jan 2020 00:00:00 +0000</pubDate>
      <guid>/note/learning-tke/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Hugo 学习笔记</title>
      <link>/note/learning-hugo/</link>
      <pubDate>Fri, 24 Jan 2020 00:00:00 +0000</pubDate>
      <guid>/note/learning-hugo/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Docker 学习笔记</title>
      <link>/note/learning-docker/</link>
      <pubDate>Fri, 24 Jan 2020 00:00:00 +0000</pubDate>
      <guid>/note/learning-docker/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Istio 学习笔记</title>
      <link>/note/learning-istio/</link>
      <pubDate>Fri, 24 Jan 2020 00:00:00 +0000</pubDate>
      <guid>/note/learning-istio/</guid>
      <description></description>
    </item>
    
    <item>
      <title>打造云原生大型分布式监控系统(四): Kvass&#43;Thanos 监控超大规模容器集群</title>
      <link>/post/202011/build-cloud-native-large-scale-distributed-monitoring-system-4/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>/post/202011/build-cloud-native-large-scale-distributed-monitoring-system-4/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#概述&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#有-thanos-不够吗-&#34;&gt;有 Thanos 不够吗 ?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#什么是-kvass-&#34;&gt;什么是 Kvass ?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#部署实践&#34;&gt;部署实践&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#部署准备&#34;&gt;部署准备&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#部署-kvass&#34;&gt;部署 Kvass&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#部署-thanos-query&#34;&gt;部署 thanos-query&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#小结&#34;&gt;小结&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;继上一篇 &lt;a href=&#34;../../202004/build-cloud-native-large-scale-distributed-monitoring-system-3/&#34;&gt;Thanos 部署与实践&lt;/a&gt; 发布半年多之后，随着技术的发展，本系列又迎来了一次更新。本文将介绍如何结合 Kvass 与 Thanos，来更好的实现大规模容器集群场景下的监控。&lt;/p&gt;
&lt;h2 id=&#34;有-thanos-不够吗-&#34;&gt;有 Thanos 不够吗 ?&lt;/h2&gt;
&lt;p&gt;有同学可能会问，Thanos 不就是为了解决 Prometheus 的分布式问题么，有了 Thanos 不就可以实现大规模的 Prometheus 监控了吗？为什么还需要个 Kvass？
Thanos 解决了 Prometheus 的分布式存储与查询的问题，但没有解决 Prometheus 分布式采集的问题，如果采集的任务和数据过多，还是会使 Prometheus 达到的瓶颈，不过对于这个问题，我们在系列的第一篇 &lt;a href=&#34;../../202003/build-cloud-native-large-scale-distributed-monitoring-system-1&#34;&gt;大规模场景下 Prometheus 的优化手段&lt;/a&gt; 中就讲了一些优化方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从服务维度拆分采集任务到不同 Prometheus 实例。&lt;/li&gt;
&lt;li&gt;使用 Prometheus 自带的 hashmod 对采集任务做分片。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是，这些优化方法还是存在一些缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置繁琐，每个 Prometheus 实例的采集配置都需要单独配。&lt;/li&gt;
&lt;li&gt;需要提前对数据规模做预估才好配置。&lt;/li&gt;
&lt;li&gt;不同 Prometheus 实例采集任务不同，负载很可能不太均衡，控制不好的话仍然可能存在部分实例负载过高的可能。&lt;/li&gt;
&lt;li&gt;如需对 Prometheus 进行扩缩容，需要手动调整，无法做到自动扩缩容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Kvass 就是为了解决这些问题而生，也是本文的重点。&lt;/p&gt;
&lt;h2 id=&#34;什么是-kvass-&#34;&gt;什么是 Kvass ?&lt;/h2&gt;
&lt;p&gt;Kvass 项目是腾讯云开源的轻量级 Prometheus 横向扩缩容方案，其巧妙的将服务发现与采集过程分离，并用 Sidecar 动态给 Prometheus 生成配置文件，从而达到无需手工配置就能实现不同 Prometheus 采集不同任务的效果，并且能够将采集任务进行负载均衡，以避免部分 Prometheus 实例负载过高，即使负载高了也可以自动扩容，再配合 Thanos 的全局视图，就可以轻松构建只使用一份配置文件的超大规模集群监控系统。下面是 Kvass+Thanos 的架构图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kvass-arch.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;更多关于 Kvass 的详细介绍，请参考 &lt;a href=&#34;https://mp.weixin.qq.com/s/P3F1grbVpb7LF2hcxYNOcg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;如何用 Prometheus 监控十万 container 的 Kubernetes 集群&lt;/a&gt; ，文章中详细介绍了原理和使用效果。&lt;/p&gt;
&lt;h2 id=&#34;部署实践&#34;&gt;部署实践&lt;/h2&gt;
&lt;h3 id=&#34;部署准备&#34;&gt;部署准备&lt;/h3&gt;
&lt;p&gt;首先下载 Kvass 的 repo 并进入 examples 目录:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone https://github.com/tkestack/kvass.git
cd kvass/examples
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在部署 Kvass 之前我们需要有服务暴露指标以便采集，我们提供了一个 metrics 数据生成器，可以指定生成一定数量的 series，在本例子中，我们将部署 6 个 metrics 生成器副本，每个会生成 10045 series，将其一键部署到集群:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create -f  metrics.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部署-kvass&#34;&gt;部署 Kvass&lt;/h3&gt;
&lt;p&gt;接着我们来部署 Kvass:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create -f kvass-rbac.yaml # Kvass 所需的 RBAC 配置
kubectl create -f config.yaml # Prometheus 配置文件
kubectl create -f coordinator.yaml # Kvass coordinator 部署配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;config.yaml&lt;/code&gt; 的 Prometheus 配置文件，配了对刚才部署的 metrics 生成器的采集:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;global:
  scrape_interval: 15s
  evaluation_interval: 15s
  external_labels:
    cluster: custom
scrape_configs:
- job_name: &#39;metrics-test&#39;
  kubernetes_sd_configs:
    - role: pod
  relabel_configs:
  - source_labels: [__meta_kubernetes_pod_label_app_kubernetes_io_name]
    regex: metrics
    action: keep
  - source_labels: [__meta_kubernetes_pod_ip]
    action: replace
    regex: (.*)
    replacement: ${1}:9091
    target_label: __address__
  - source_labels:
    - __meta_kubernetes_pod_name
    target_label: pod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;coordinator.yaml&lt;/code&gt; 我们给 Coordinator 的启动参数中设置每个分片的最大 head series 数目不超过 30000:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ndash;shard.max-series=30000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后部署 Prometheus 实例(包含 Thanos Sidecar 与 Kvass Sidecar)，一开始可以只需要单个副本:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create -f prometheus-rep-0.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;如果需要将数据存储到对象存储，请参考上一篇 &lt;a href=&#34;https://imroc.io/posts/build-cloud-native-large-scale-distributed-monitoring-system-3/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Thanos 部署与实践&lt;/a&gt; 对 Thanos Sidecar 的配置进行修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;部署-thanos-query&#34;&gt;部署 thanos-query&lt;/h3&gt;
&lt;p&gt;为了得到全局数据，我们需要部署一个 thanos-query:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create -f thanos-query.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据上述计算，监控目标总计 6  个 target, 60270 series，根据我们设置每个分片不能超过 30000 series，则预期需要 3 个分片。我们发现，Coordinator 成功将 StatefulSet 的副本数改成了 3。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get pods
NAME                                READY   STATUS    RESTARTS   AGE
kvass-coordinator-c68f445f6-g9q5z   2/2     Running   0          64s
metrics-5876dccf65-5cncw            1/1     Running   0          75s
metrics-5876dccf65-6tw4b            1/1     Running   0          75s
metrics-5876dccf65-dzj2c            1/1     Running   0          75s
metrics-5876dccf65-gz9qd            1/1     Running   0          75s
metrics-5876dccf65-r25db            1/1     Running   0          75s
metrics-5876dccf65-tdqd7            1/1     Running   0          75s
prometheus-rep-0-0                  3/3     Running   0          54s
prometheus-rep-0-1                  3/3     Running   0          45s
prometheus-rep-0-2                  3/3     Running   0          45s
thanos-query-69b9cb857-d2b45        1/1     Running   0          49s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再通过 thanos-query 来查看全局数据，发现数据是完整的(其中 metrics0 为指标生成器生成的指标名):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;build-cloud-native-large-scale-distributed-monitoring-system-4/image-20201125110446591.png&#34; alt=&#34;image-20201125110446591&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;build-cloud-native-large-scale-distributed-monitoring-system-4/image-20201125110534688.png&#34; alt=&#34;image-20201125110534688&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果需要用 Grafana 面板查看监控数据，可以添加 thanos-query 地址作为 Prometheus 数据源: &lt;code&gt;http://thanos-query.default.svc.cluster.local:9090&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文介绍了如何结合 Kvass 与 Thanos 来实现超大规模容器集群的监控，如果你使用了腾讯云容器服务，可以直接使用运维中心下的 &lt;code&gt;云原生监控&lt;/code&gt; 服务，此服务就是基于 Kvass 构建的产品。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nginx Ingress 高并发实践</title>
      <link>/post/202009/nginx-ingress-high-concurrency/</link>
      <pubDate>Wed, 02 Sep 2020 20:50:00 +0800</pubDate>
      <guid>/post/202009/nginx-ingress-high-concurrency/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#概述&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#内核参数调优&#34;&gt;内核参数调优&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#调大连接队列的大小&#34;&gt;调大连接队列的大小&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#扩大源端口范围&#34;&gt;扩大源端口范围&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#time_wait-复用&#34;&gt;TIME_WAIT 复用&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#调大最大文件句柄数&#34;&gt;调大最大文件句柄数&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#配置示例&#34;&gt;配置示例&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#全局配置调优&#34;&gt;全局配置调优&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#调高-keepalive-连接最大请求数&#34;&gt;调高 keepalive 连接最大请求数&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#调高-keepalive-最大空闲连接数&#34;&gt;调高 keepalive 最大空闲连接数&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#调高单个-worker-最大连接数&#34;&gt;调高单个 worker 最大连接数&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#配置示例-1&#34;&gt;配置示例&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#总结&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#参考资料&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Nginx Ingress Controller 基于 Nginx 实现了 Kubernetes Ingress API，Nginx 是公认的高性能网关，但如果不对其进行一些参数调优，就不能充分发挥出高性能的优势。之前我们在 &lt;a href=&#34;https://imroc.io/posts/nginx-ingress-on-tke/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nginx Ingress on TKE 部署最佳实践&lt;/a&gt; 一文中讲了 Nginx Ingress 在 TKE 上部署最佳实践，涉及的部署 YAML 其实已经包含了一些性能方面的参数优化，只是没有提及，本文将继续展开介绍针对 Nginx Ingress 的一些全局配置与内核参数调优的建议，可用于支撑我们的高并发业务。&lt;/p&gt;
&lt;h2 id=&#34;内核参数调优&#34;&gt;内核参数调优&lt;/h2&gt;
&lt;p&gt;我们先看下如何对 Nginx Ingress 进行内核参数调优，设置内核参数的方法可以用 initContainers 的方式，后面会有示例。&lt;/p&gt;
&lt;h3 id=&#34;调大连接队列的大小&#34;&gt;调大连接队列的大小&lt;/h3&gt;
&lt;p&gt;进程监听的 socket 的连接队列最大的大小受限于内核参数  &lt;code&gt;net.core.somaxconn&lt;/code&gt;，在高并发环境下，如果队列过小，可能导致队列溢出，使得连接部分连接无法建立。要调大 Nginx Ingress 的连接队列，只需要调整 somaxconn 内核参数的值即可，但我想跟你分享下这背后的相关原理。&lt;/p&gt;
&lt;p&gt;进程调用 listen 系统调用来监听端口的时候，还会传入一个 backlog 的参数，这个参数决定 socket 的连接队列大小，其值不得大于 somaxconn 的取值。Go 程序标准库在 listen 时，默认直接读取 somaxconn 作为队列大小，但 Nginx 监听 socket 时没有读取 somaxconn，而是有自己单独的参数配置。在 &lt;code&gt;nginx.conf&lt;/code&gt; 中 listen 端口的位置，还有个叫 backlog 参数可以设置，它会决定 nginx listen 的端口的连接队列大小。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nginx.conf&#34;&gt;server {
    listen  80  backlog=1024;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不设置，backlog 在 linux 上默认为 511:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;backlog=number
   sets the backlog parameter in the listen() call that limits the maximum length for the queue of pending connections. By default, backlog is set to -1 on FreeBSD, DragonFly BSD, and macOS, and to 511 on other platforms.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说，即便你的 somaxconn 配的很高，nginx 所监听端口的连接队列最大却也只有 511，高并发场景下可能导致连接队列溢出。&lt;/p&gt;
&lt;p&gt;不过这个在 Nginx Ingress 这里情况又不太一样，因为 Nginx Ingress Controller 会自动读取 somaxconn 的值作为 backlog 参数写到生成的 nginx.conf 中: &lt;a href=&#34;https://github.com/kubernetes/ingress-nginx/blob/controller-v0.34.1/internal/ingress/controller/nginx.go#L592&#34;&gt;https://github.com/kubernetes/ingress-nginx/blob/controller-v0.34.1/internal/ingress/controller/nginx.go#L592&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也就是说，Nginx Ingress 的连接队列大小只取决于 somaxconn 的大小，这个值在 TKE 默认为 4096，建议给 Nginx Ingress 设为 65535: &lt;code&gt;sysctl -w net.core.somaxconn=65535&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;扩大源端口范围&#34;&gt;扩大源端口范围&lt;/h3&gt;
&lt;p&gt;高并发场景会导致 Nginx Ingress 使用大量源端口与 upstream 建立连接，源端口范围从 &lt;code&gt;net.ipv4.ip_local_port_range&lt;/code&gt; 这个内核参数中定义的区间随机选取，在高并发环境下，端口范围小容易导致源端口耗尽，使得部分连接异常。TKE 环境创建的 Pod 源端口范围默认是 32768-60999，建议将其扩大，调整为 1024-65535: &lt;code&gt;sysctl -w net.ipv4.ip_local_port_range=&amp;quot;1024 65535&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;time_wait-复用&#34;&gt;TIME_WAIT 复用&lt;/h3&gt;
&lt;p&gt;如果短连接并发量较高，它所在 netns 中 TIME_WAIT 状态的连接就比较多，而 TIME_WAIT 连接默认要等 2MSL 时长才释放，长时间占用源端口，当这种状态连接数量累积到超过一定量之后可能会导致无法新建连接。&lt;/p&gt;
&lt;p&gt;所以建议给 Nginx Ingress 开启 TIME_WAIT 重用，即允许将 TIME_WAIT 连接重新用于新的 TCP 连接: &lt;code&gt;sysctl -w net.ipv4.tcp_tw_reuse=1&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;调大最大文件句柄数&#34;&gt;调大最大文件句柄数&lt;/h3&gt;
&lt;p&gt;Nginx 作为反向代理，对于每个请求，它会与 client 和 upstream server 分别建立一个连接，即占据两个文件句柄，所以理论上来说 Nginx 能同时处理的连接数最多是系统最大文件句柄数限制的一半。&lt;/p&gt;
&lt;p&gt;系统最大文件句柄数由 &lt;code&gt;fs.file-max&lt;/code&gt; 这个内核参数来控制，TKE 默认值为 838860，建议调大: &lt;code&gt;sysctl -w fs.file-max=1048576&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;配置示例&#34;&gt;配置示例&lt;/h3&gt;
&lt;p&gt;给 Nginx Ingress Controller 的 Pod 添加 initContainers 来设置内核参数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;      initContainers:
      - name: setsysctl
        image: busybox
        securityContext:
          privileged: true
        command:
        - sh
        - -c
        - |
          sysctl -w net.core.somaxconn=65535
          sysctl -w net.ipv4.ip_local_port_range=&amp;quot;1024 65535&amp;quot;
          sysctl -w net.ipv4.tcp_tw_reuse=1
          sysctl -w fs.file-max=1048576
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;全局配置调优&#34;&gt;全局配置调优&lt;/h2&gt;
&lt;p&gt;除了内核参数需要调优，Nginx 本身的一些配置也需要进行调优，下面我们来详细看下。&lt;/p&gt;
&lt;h3 id=&#34;调高-keepalive-连接最大请求数&#34;&gt;调高 keepalive 连接最大请求数&lt;/h3&gt;
&lt;p&gt;Nginx 针对 client 和 upstream 的 keepalive 连接，均有 keepalive_requests 这个参数来控制单个 keepalive 连接的最大请求数，且默认值均为 100。当一个 keepalive 连接中请求次数超过这个值时，就会断开并重新建立连接。&lt;/p&gt;
&lt;p&gt;如果是内网 Ingress，单个 client 的 QPS 可能较大，比如达到 10000 QPS，Nginx 就可能频繁断开跟 client 建立的 keepalive 连接，然后就会产生大量 TIME_WAIT 状态连接。我们应该尽量避免产生大量 TIME_WAIT 连接，所以，建议这种高并发场景应该增大 Nginx 与 client 的 keepalive 连接的最大请求数量，在 Nginx Ingress 的配置对应 &lt;code&gt;keep-alive-requests&lt;/code&gt;，可以设置为 10000，参考: &lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#keep-alive-requests&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#keep-alive-requests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同样的，Nginx 与 upstream 的 keepalive 连接的请求数量的配置是 &lt;code&gt;upstream-keepalive-requests&lt;/code&gt;，参考: &lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#upstream-keepalive-requests&#34;&gt;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#upstream-keepalive-requests&lt;/a&gt; 但是，一般情况应该不必配此参数，如果将其调高，可能导致负载不均，因为 Nginx 与 upstream 保持的 keepalive 连接过久，导致连接发生调度的次数就少了，连接就过于 &amp;ldquo;固化&amp;rdquo;，使得流量的负载不均衡。&lt;/p&gt;
&lt;h3 id=&#34;调高-keepalive-最大空闲连接数&#34;&gt;调高 keepalive 最大空闲连接数&lt;/h3&gt;
&lt;p&gt;Nginx 针对 upstream 有个叫 keepalive 的配置，它不是 keepalive 超时时间，也不是 keepalive 最大连接数，而是 keepalive 最大空闲连接数。&lt;/p&gt;
&lt;p&gt;它的默认值为 32，在高并发下场景下会产生大量请求和连接，而现实世界中请求并不是完全均匀的，有些建立的连接可能会短暂空闲，而空闲连接数多了之后关闭空闲连接，就可能导致 Nginx 与 upstream 频繁断连和建连，引发 TIME_WAIT 飙升。在高并发场景下可以调到 1000，参考: &lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#upstream-keepalive-connections&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#upstream-keepalive-connections&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;调高单个-worker-最大连接数&#34;&gt;调高单个 worker 最大连接数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;max-worker-connections&lt;/code&gt; 控制每个 worker 进程可以打开的最大连接数，TKE 环境默认 16384，在高并发环境建议调高，比如设置到 65536，这样可以让 nginx 拥有处理更多连接的能力，参考: &lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#max-worker-connections&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#max-worker-connections&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置示例-1&#34;&gt;配置示例&lt;/h3&gt;
&lt;p&gt;Nginx 全局配置通过 configmap 配置(Nginx Ingress Controller 会 watch 并自动 reload 配置):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-ingress-controller
# nginx ingress 性能优化: https://www.nginx.com/blog/tuning-nginx/
data:
  # nginx 与 client 保持的一个长连接能处理的请求数量，默认 100，高并发场景建议调高。
  # 参考: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#keep-alive-requests
  keep-alive-requests: &amp;quot;10000&amp;quot;
  # nginx 与 upstream 保持长连接的最大空闲连接数 (不是最大连接数)，默认 32，在高并发下场景下调大，避免频繁建联导致 TIME_WAIT 飙升。
  # 参考: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#upstream-keepalive-connections
  upstream-keepalive-connections: &amp;quot;200&amp;quot;
  # 每个 worker 进程可以打开的最大连接数，默认 16384。
  # 参考: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#max-worker-connections
  max-worker-connections: &amp;quot;65536&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文分享了对 Nginx Ingress 进行性能调优的方法及其原理的解释，包括内核参数与 Nginx 本身的配置调优，更好的适配高并发的业务场景，希望对大家有所帮助。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Nginx Ingress on TKE 部署最佳实践: &lt;a href=&#34;https://mp.weixin.qq.com/s/NAwz4dlsPuJnqfWYBHkfGg&#34;&gt;https://mp.weixin.qq.com/s/NAwz4dlsPuJnqfWYBHkfGg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nginx Ingress 配置参考:  &lt;a href=&#34;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/&#34;&gt;https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tuning NGINX for Performance: &lt;a href=&#34;https://www.nginx.com/blog/tuning-nginx/&#34;&gt;https://www.nginx.com/blog/tuning-nginx/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ngx_http_upstream_module 官方文档: &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_upstream_module.html&#34;&gt;http://nginx.org/en/docs/http/ngx_http_upstream_module.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Nginx Ingress on TKE 部署最佳实践</title>
      <link>/post/202008/nginx-ingress-on-tke/</link>
      <pubDate>Fri, 07 Aug 2020 11:00:00 +0800</pubDate>
      <guid>/post/202008/nginx-ingress-on-tke/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#概述&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#什么是-nginx-ingress-&#34;&gt;什么是 Nginx Ingress ?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#有哪些部署方案-&#34;&gt;有哪些部署方案 ?&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#方案一-deployment--lb&#34;&gt;方案一： Deployment + LB&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#方案二daemonset--hostnetwork--lb&#34;&gt;方案二：Daemonset + HostNetwork + LB&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#方案三deployment--lb-直通-pod&#34;&gt;方案三：Deployment + LB 直通 Pod&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何选型&#34;&gt;如何选型？&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何支持内网-ingress-&#34;&gt;如何支持内网 Ingress ?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何复用已有-lb-&#34;&gt;如何复用已有 LB ?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#nginx-ingress-公网带宽有多大&#34;&gt;Nginx Ingress 公网带宽有多大？&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何创建-ingress-&#34;&gt;如何创建 Ingress ?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何监控&#34;&gt;如何监控？&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#总结&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#参考资料&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;开源的 Ingress Controller 的实现使用量最大的莫过于 Nginx Ingress 了，功能强大且性能极高。Nginx Ingress 有多种部署方式，本文将介绍 Nginx Ingress 在 TKE 上的一些部署方案，这几种方案的原理、各自优缺点以及一些选型和使用上的建议。&lt;/p&gt;
&lt;h2 id=&#34;什么是-nginx-ingress-&#34;&gt;什么是 Nginx Ingress ?&lt;/h2&gt;
&lt;p&gt;在介绍如何部署 Nginx Ingress 之前，我们先简单了解下什么是 Nginx Ingress。&lt;/p&gt;
&lt;p&gt;Nginx Ingress 是 Kubernetes Ingress 的一种实现，它通过 watch Kubernetes 集群的 Ingress 资源，将 Ingress 规则转换成 Nginx 的配置，然后让 Nginx 来进行 7 层的流量转发:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/nginx-ingress-on-tke-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;实际 Nginx Ingress 有两种实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/kubernetes/ingress-nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nginxinc/kubernetes-ingress&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/nginxinc/kubernetes-ingress&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种是 Kubernetes 开源社区的实现，第二种是 Nginx 官方的实现，我们通常用的是 Kubernetes 社区的实现，这也是本文所关注的重点。&lt;/p&gt;
&lt;h2 id=&#34;有哪些部署方案-&#34;&gt;有哪些部署方案 ?&lt;/h2&gt;
&lt;p&gt;那么如何在 TKE 上部署 Nginx Ingress 呢？主要有三种方案，下面分别介绍下这几种方案及其部署方法。&lt;/p&gt;
&lt;h3 id=&#34;方案一-deployment--lb&#34;&gt;方案一： Deployment + LB&lt;/h3&gt;
&lt;p&gt;在 TKE 上部署 Nginx Ingress 最简单的方式就是将 Nginx Ingress Controller 以 Deployment 的方式部署，并且为其创建 LoadBalancer 类型的 Service(可以是自动创建 CLB 也可以是绑定已有 CLB)，这样就可以让 CLB 接收外部流量，然后转发到 Nginx Ingress 内部：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/nginx-ingress-on-tke-2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当前 TKE 上 LoadBalancer 类型的 Service 默认实现是基于 NodePort，CLB 会绑定各节点的 NodePort 作为后端 rs，将流量转发到节点的 NodePort，然后节点上再通过 Iptables 或 IPVS 将请求路由到 Service 对应的后端 Pod，这里的 Pod 就是 Nginx Ingress Controller 的 Pod。后续如果有节点的增删，CLB 也会自动更新节点 NodePort 的绑定。&lt;/p&gt;
&lt;p&gt;这是最简单的一种方式，可以直接通过下面命令安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create ns nginx-ingress
kubectl apply -f https://raw.githubusercontent.com/TencentCloudContainerTeam/manifest/master/nginx-ingress/nginx-ingress-deployment.yaml -n nginx-ingress
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方案二daemonset--hostnetwork--lb&#34;&gt;方案二：Daemonset + HostNetwork + LB&lt;/h3&gt;
&lt;p&gt;方案一虽然简单，但是流量会经过一层 NodePort，会多一层转发。这种方式有一些缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;转发路径较长，流量到了 NodePort 还会再经过 Kubernetes 内部负载均衡，通过 Iptables 或 IPVS 转发到 Nginx，会增加一点网络耗时。&lt;/li&gt;
&lt;li&gt;经过 NodePort 必然发生 SNAT，如果流量过于集中容易导致源端口耗尽或者 conntrack 插入冲突导致丢包，引发部分流量异常。&lt;/li&gt;
&lt;li&gt;每个节点的 NodePort 也充当一个负载均衡器，CLB 如果绑定大量节点的 NodePort，负载均衡的状态就分散在每个节点上，容易导致全局负载不均。&lt;/li&gt;
&lt;li&gt;CLB 会对 NodePort 进行健康探测，探测包最终会被转发到 Nginx Ingress 的 Pod，如果 CLB 绑定的节点多，Nginx Ingress 的 Pod 少，会导致探测包对 Nginx Ingress 造成较大的压力。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以让 Nginx Ingress 使用 hostNetwork，CLB 直接绑节点 IP + 端口(80,443)， 这样就不用走 NodePort；由于使用 hostNetwork，Nginx Ingress 的 pod 就不能被调度到同一节点避免端口监听冲突。通常做法是提前规划好，选取部分节点作为边缘节点，专门用于部署 Nginx Ingress，为这些节点打上 label，然后 Nginx Ingress 以 DaemonSet 方式部署在这些节点上。下面是架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/nginx-ingress-on-tke-3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;安装步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将规划好的用于部署 Nginx Ingress 的节点打上 label: &lt;code&gt;kubectl label node 10.0.0.3 nginx-ingress=true&lt;/code&gt;(注意替换节点名称)。&lt;/li&gt;
&lt;li&gt;将 Nginx Ingress 部署在这些节点上:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create ns nginx-ingress
kubectl apply -f https://raw.githubusercontent.com/TencentCloudContainerTeam/manifest/master/nginx-ingress/nginx-ingress-daemonset-hostnetwork.yaml -n nginx-ingress
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;手动创建 CLB，创建 80 和 443 端口的 TCP 监听器，分别绑定部署了 Nginx Ingress 的这些节点的 80 和 443 端口。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;方案三deployment--lb-直通-pod&#34;&gt;方案三：Deployment + LB 直通 Pod&lt;/h3&gt;
&lt;p&gt;方案二虽然相比方案一有一些优势，但同时也引入了手动维护 CLB 和 Nginx Ingress 节点的运维成本，需要提前规划好 Nginx Ingress 的节点，增删 Nginx Ingress 节点时需要手动在 CLB 控制台绑定和解绑节点，也无法支持自动扩缩容。&lt;br /&gt;如果你的网络模式是 VPC-CNI，那么所有的 Pod 都使用的弹性网卡，弹性网卡的 Pod 是支持 CLB 直接绑 Pod 的，可以绕过 NodePort，并且不用手动管理 CLB，支持自动扩缩容:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/nginx-ingress-on-tke-4.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果你的网络模式是 Global Router(大多集群都是这种模式)，你可以为集群开启 VPC-CNI 的支持，即两种网络模式混用，在集群信息页可打开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/nginx-ingress-on-tke-5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;确保集群支持 VPC-CNI 之后，可以使用下面命令安装 Nginx Ingress:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create ns nginx-ingress
kubectl apply -f https://raw.githubusercontent.com/TencentCloudContainerTeam/manifest/master/nginx-ingress/nginx-ingress-deployment-eni.yaml -n nginx-ingress
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;如何选型&#34;&gt;如何选型？&lt;/h2&gt;
&lt;p&gt;前面介绍了 Nginx Ingress 在 TKE 上部署的三种方案，也说了各种方案的优缺点，这里做一个简单汇总下，给出一些选型建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方案一较为简单通用，但在大规模和高并发场景可能有一点性能问题。如果对性能要求不那么严格，可以考虑使用这种方案。&lt;/li&gt;
&lt;li&gt;方案二使用 hostNetwork 性能好，但需要手动维护 CLB 和 Nginx Ingress 节点，也无法实现自动扩缩容，通常不太建议用这种方案。&lt;/li&gt;
&lt;li&gt;方案三性能好，而且不需要手动维护 CLB，是最理想的方案。它需要集群支持 VPC-CNI，如果你的集群本身用的 VPC-CNI 网络插件，或者用的 Global Router 网络插件并开启了 VPC-CNI 的支持(两种模式混用)，那么建议直接使用这种方案。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何支持内网-ingress-&#34;&gt;如何支持内网 Ingress ?&lt;/h2&gt;
&lt;p&gt;方案二由于是手动管理 CLB，自行创建 CLB 时可以选择用公网还是内网；方案一和方案三默认会创建公网 CLB，如果要用内网，可以改下部署 YAML，给 &lt;code&gt;nginx-ingress-controller&lt;/code&gt; 这个 Service 加一个 key 为 &lt;code&gt;service.kubernetes.io/qcloud-loadbalancer-internal-subnetid&lt;/code&gt;，value 为内网 CLB 所被创建的子网 id 的 annotation，示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  annotations:
    service.kubernetes.io/qcloud-loadbalancer-internal-subnetid: subnet-xxxxxx # value 替换为集群所在 vpc 的其中一个子网 id
  labels:
    app: nginx-ingress
    component: controller
  name: nginx-ingress-controller
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;如何复用已有-lb-&#34;&gt;如何复用已有 LB ?&lt;/h2&gt;
&lt;p&gt;方案一和方案三默认会自动创建新的 CLB，Ingress 的流量入口地址取决于新创建出来的 CLB 的 IP 地址。如果业务对入口地址有依赖，比如配置了 DNS 解析到之前的 CLB IP，不希望切换 IP；或者想使用包年包月的 CLB (默认创建是按量计费)，那么也可以让 Nginx Ingress 绑定已有的 CLB。&lt;/p&gt;
&lt;p&gt;操作方法同样也是修改下部署 yaml，给 &lt;code&gt;nginx-ingress-controller&lt;/code&gt; 这个 Service 加一个 key 为 &lt;code&gt;service.kubernetes.io/tke-existed-lbid&lt;/code&gt;，value 为 CLB ID 的 annotation，示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  annotations:
    service.kubernetes.io/tke-existed-lbid: lb-6swtxxxx # value 替换为 CLB 的 ID
  labels:
    app: nginx-ingress
    component: controller
  name: nginx-ingress-controller
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nginx-ingress-公网带宽有多大&#34;&gt;Nginx Ingress 公网带宽有多大？&lt;/h2&gt;
&lt;p&gt;有同学可能会问：我的 Nginx Ingress 的公网带宽到底有多大？能否支撑住我服务的并发量？&lt;/p&gt;
&lt;p&gt;这里需要普及一下，腾讯云账号有带宽上移和非带宽上移两种类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非带宽上移，是指带宽在云主机(CVM)上管理。&lt;/li&gt;
&lt;li&gt;带宽上移，是指带宽上移到了 CLB 或 IP 上管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体来讲，如果你的账号是非带宽上移类型，Nginx Ingress 使用公网 CLB，那么 Nginx Ingress 的公网带宽是 CLB 所绑定的 TKE 节点的带宽之和；如果使用方案三，CLB 直通 Pod，也就是 CLB 不是直接绑的 TKE 节点，而是弹性网卡，那么此时 Nginx Ingress 的公网带宽是所有 Nginx Ingress Controller Pod 被调度到的节点上的带宽之和。&lt;/p&gt;
&lt;p&gt;如果你的账号是带宽上移类型就简单了，Nginx Ingress 的带宽就等于你所购买的 CLB 的带宽，默认是 10Mbps (按量计费)，你可以按需调整下。&lt;/p&gt;
&lt;p&gt;由于历史遗留原因，以前注册的账号大多是非带宽上移类型，参考 &lt;a href=&#34;https://cloud.tencent.com/document/product/684/39903&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt; 来区分自己账号的类型。&lt;/p&gt;
&lt;h2 id=&#34;如何创建-ingress-&#34;&gt;如何创建 Ingress ?&lt;/h2&gt;
&lt;p&gt;目前还没有完成对 Nginx Ingress 的产品化支持，所以如果是在 TKE 上自行了部署 Nginx Ingress，想要使用 Nginx Ingress 来管理 Ingress，目前是无法通过在 TKE 控制台(网页) 上进行操作的，只有通过 YAML 的方式来创建，并且需要给每个 Ingress 都指定 Ingress Class 的 annotation，示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: test-ingress
  annotations:
    kubernetes.io/ingress.class: nginx # 这里是重点
spec:
  rules:
  - host: *
    http:
      paths:
      - path: /
        backend:
          serviceName: nginx-v1
          servicePort: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;如何监控&#34;&gt;如何监控？&lt;/h2&gt;
&lt;p&gt;通过上面的方法安装的 Nginx Ingress，已经暴露了 metrics 端口，可以被 Prometheus 采集。如果集群内安装了 prometheus-operator，可以使用下面的 ServiceMonitor 来采集 Nginx Ingress 的监控数据:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: nginx-ingress-controller
  namespace: nginx-ingress
  labels:
    app: nginx-ingress
    component: controller
spec:
  endpoints:
  - port: metrics
    interval: 10s
  namespaceSelector:
    matchNames:
    - nginx-ingress
  selector:
    matchLabels:
      app: nginx-ingress
      component: controller
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里也给个原生 Prometheus 配置的示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    - job_name: nginx-ingress
      scrape_interval: 5s
      kubernetes_sd_configs:
      - role: endpoints
        namespaces:
          names:
          - nginx-ingress
      relabel_configs:
      - action: keep
        source_labels:
        - __meta_kubernetes_service_label_app
        - __meta_kubernetes_service_label_component
        regex: nginx-ingress;controller
      - action: keep
        source_labels:
        - __meta_kubernetes_endpoint_port_name
        regex: metrics
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了数据后，我们再给 grafana 配置一下面板来展示数据，Nginx Ingress 社区提供了面板： &lt;a href=&#34;https://github.com/kubernetes/ingress-nginx/tree/master/deploy/grafana/dashboards&#34;&gt;https://github.com/kubernetes/ingress-nginx/tree/master/deploy/grafana/dashboards&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们直接复制 json 导入到 grafana 即可导入面板。其中，&lt;code&gt;nginx.json&lt;/code&gt; 是展示 Nginx Ingress 各种常规监控的面板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/nginx-ingress-on-tke-6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;request-handling-performance.json&lt;/code&gt; 是展示 Nginx Ingress 性能方面的监控面板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/nginx-ingress-on-tke-7.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文梳理了 Nginx Ingress 在 TKE 上部署的三种方案以及许多实用的建议，对于想要在 TKE 上使用 Nginx Ingress 的同学是一个很好的参考。由于 Nginx Ingress 的使用需求量较大，我们也正在做 Nginx Ingress 的产品化支持， 可以实现一键部署，集成日志和监控能力，并且会对其进行性能优化。相信在不久的将来，我们就能够在 TKE 上更简单高效的使用 Nginx Ingress 了，敬请期待吧！&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;TKE Service YAML 示例: &lt;a href=&#34;https://cloud.tencent.com/document/product/457/45489#yaml-.E7.A4.BA.E4.BE.8B&#34;&gt;https://cloud.tencent.com/document/product/457/45489#yaml-.E7.A4.BA.E4.BE.8B&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;TKE Service 使用已有 CLB: &lt;a href=&#34;https://cloud.tencent.com/document/product/457/45491&#34;&gt;https://cloud.tencent.com/document/product/457/45491&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;区分腾讯云账户类型: &lt;a href=&#34;https://cloud.tencent.com/document/product/684/39903&#34;&gt;https://cloud.tencent.com/document/product/684/39903&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 服务部署最佳实践(二) 如何提高服务可用性</title>
      <link>/post/202006/kubernetes-app-deployment-best-practice-2/</link>
      <pubDate>Fri, 19 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/post/202006/kubernetes-app-deployment-best-practice-2/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#引言&#34;&gt;引言&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何避免单点故障&#34;&gt;如何避免单点故障？&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何避免节点维护或升级时导致服务不可用&#34;&gt;如何避免节点维护或升级时导致服务不可用？&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何让服务进行平滑更新&#34;&gt;如何让服务进行平滑更新？&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#健康检查怎么配才好&#34;&gt;健康检查怎么配才好？&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#参考资料&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://imroc.io/posts/kubernetes-app-deployment-best-practice-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;上一篇&lt;/a&gt; 文章我们围绕如何合理利用资源的主题做了一些最佳实践的分享，这一次我们就如何提高服务可用性的主题来展开探讨。&lt;/p&gt;
&lt;p&gt;怎样提高我们部署服务的可用性呢？K8S 设计本身就考虑到了各种故障的可能性，并提供了一些自愈机制以提高系统的容错性，但有些情况还是可能导致较长时间不可用，拉低服务可用性的指标。本文将结合生产实践经验，为大家提供一些最佳实践来最大化的提高服务可用性。&lt;/p&gt;
&lt;h2 id=&#34;如何避免单点故障&#34;&gt;如何避免单点故障？&lt;/h2&gt;
&lt;p&gt;K8S 的设计就是假设节点是不可靠的。节点越多，发生软硬件故障导致节点不可用的几率就越高，所以我们通常需要给服务部署多个副本，根据实际情况调整 replicas 的值，如果值为 1 就必然存在单点故障，如果大于 1 但所有副本都调度到同一个节点了，那还是有单点故障，有时候还要考虑到灾难，比如整个机房不可用。&lt;/p&gt;
&lt;p&gt;所以我们不仅要有合理的副本数量，还需要让这些不同副本调度到不同的拓扑域(节点、可用区)，打散调度以避免单点故障，这个可以利用 Pod 反亲和性来做到，反亲和主要分强反亲和与弱反亲和两种。&lt;/p&gt;
&lt;p&gt;先来看个强反亲和的示例，将 dns 服务强制打散调度到不同节点上:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;affinity:
 podAntiAffinity:
   requiredDuringSchedulingIgnoredDuringExecution:
   - labelSelector:
       matchExpressions:
       - key: k8s-app
         operator: In
         values:
         - kube-dns
     topologyKey: kubernetes.io/hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;labelSelector.matchExpressions&lt;/code&gt; 写该服务对应 pod 中 labels 的 key 与 value，因为 Pod 反亲和性是通过判断 replicas 的 pod label 来实现的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;topologyKey&lt;/code&gt; 指定反亲和的拓扑域，即节点 label 的 key。这里用的 &lt;code&gt;kubernetes.io/hostname&lt;/code&gt; 表示避免 pod 调度到同一节点，如果你有更高的要求，比如避免调度到同一个可用区，实现异地多活，可以用 &lt;code&gt;failure-domain.beta.kubernetes.io/zone&lt;/code&gt;。通常不会去避免调度到同一个地域，因为一般同一个集群的节点都在一个地域，如果跨地域，即使用专线时延也会很大，所以 &lt;code&gt;topologyKey&lt;/code&gt; 一般不至于用 &lt;code&gt;failure-domain.beta.kubernetes.io/region&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/code&gt; 调度时必须满足该反亲和性条件，如果没有节点满足条件就不调度到任何节点 (Pending)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不用这种硬性条件可以使用 &lt;code&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/code&gt; 来指示调度器尽量满足反亲和性条件，即弱反亲和性，如果实在没有满足条件的，只要节点有足够资源，还是可以让其调度到某个节点，至少不会 Pending。&lt;/p&gt;
&lt;p&gt;我们再来看个弱反亲和的示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: k8s-app
            operator: In
            values:
            - kube-dns
      topologyKey: kubernetes.io/hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意到了吗？相比强反亲和有些不同哦，多了一个 &lt;code&gt;weight&lt;/code&gt;，表示此匹配条件的权重，而匹配条件被挪到了 &lt;code&gt;podAffinityTerm&lt;/code&gt; 下面。&lt;/p&gt;
&lt;h2 id=&#34;如何避免节点维护或升级时导致服务不可用&#34;&gt;如何避免节点维护或升级时导致服务不可用？&lt;/h2&gt;
&lt;p&gt;有时候我们需要对节点进行维护或进行版本升级等操作，操作之前需要对节点执行驱逐 (kubectl drain)，驱逐时会将节点上的 Pod 进行删除，以便它们漂移到其它节点上，当驱逐完毕之后，节点上的 Pod 都漂移到其它节点了，这时我们就可以放心的对节点进行操作了。&lt;/p&gt;
&lt;p&gt;有一个问题就是，驱逐节点是一种有损操作，驱逐的原理:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;封锁节点 (设为不可调度，避免新的 Pod 调度上来)。&lt;/li&gt;
&lt;li&gt;将该节点上的 Pod 删除。&lt;/li&gt;
&lt;li&gt;ReplicaSet 控制器检测到 Pod 减少，会重新创建一个 Pod，调度到新的节点上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程是先删除，再创建，并非是滚动更新，因此更新过程中，如果一个服务的所有副本都在被驱逐的节点上，则可能导致该服务不可用。&lt;/p&gt;
&lt;p&gt;我们再来下什么情况下驱逐会导致服务不可用:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务存在单点故障，所有副本都在同一个节点，驱逐该节点时，就可能造成服务不可用。&lt;/li&gt;
&lt;li&gt;服务没有单点故障，但刚好这个服务涉及的 Pod 全部都部署在这一批被驱逐的节点上，所以这个服务的所有 Pod 同时被删，也会造成服务不可用。&lt;/li&gt;
&lt;li&gt;服务没有单点故障，也没有全部部署到这一批被驱逐的节点上，但驱逐时造成这个服务的一部分 Pod 被删，短时间内服务的处理能力下降导致服务过载，部分请求无法处理，也就降低了服务可用性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对第一点，我们可以使用前面讲的反亲和性来避免单点故障。&lt;/p&gt;
&lt;p&gt;针对第二和第三点，我们可以通过配置 PDB (PodDisruptionBudget) 来避免所有副本同时被删除，驱逐时 K8S 会 &amp;ldquo;观察&amp;rdquo; nginx 的当前可用与期望的副本数，根据定义的 PDB 来控制 Pod 删除速率，达到阀值时会等待 Pod 在其它节点上启动并就绪后再继续删除，以避免同时删除太多的 Pod 导致服务不可用或可用性降低，下面给出两个示例。&lt;/p&gt;
&lt;p&gt;示例一 (保证驱逐时 nginx 至少有 90% 的副本可用):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: zk-pdb
spec:
  minAvailable: 90%
  selector:
    matchLabels:
      app: zookeeper
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例二 (保证驱逐时 zookeeper 最多有一个副本不可用，相当于逐个删除并等待在其它节点完成重建):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: zk-pdb
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app: zookeeper
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;如何让服务进行平滑更新&#34;&gt;如何让服务进行平滑更新？&lt;/h2&gt;
&lt;p&gt;解决了服务单点故障和驱逐节点时导致的可用性降低问题后，我们还需要考虑一种可能导致可用性降低的场景，那就是滚动更新。为什么服务正常滚动更新也可能影响服务的可用性呢？别急，下面我来解释下原因。&lt;/p&gt;
&lt;p&gt;假如集群内存在服务间调用:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/tke-best-practices-and-troubleshooting/rolling-update-interupt-connection-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当 server 端发生滚动更新时:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/tke-best-practices-and-troubleshooting/rolling-update-interupt-connection-4.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;发生两种尴尬的情况:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;旧的副本很快销毁，而 client 所在节点 kube-proxy 还没更新完转发规则，仍然将新连接调度给旧副本，造成连接异常，可能会报 &amp;ldquo;connection refused&amp;rdquo; (进程停止过程中，不再接受新请求) 或 &amp;ldquo;no route to host&amp;rdquo; (容器已经完全销毁，网卡和 IP 已不存在)。&lt;/li&gt;
&lt;li&gt;新副本启动，client 所在节点 kube-proxy 很快 watch 到了新副本，更新了转发规则，并将新连接调度给新副本，但容器内的进程启动很慢 (比如 Tomcat 这种 java 进程)，还在启动过程中，端口还未监听，无法处理连接，也造成连接异常，通常会报 &amp;ldquo;connection refused&amp;rdquo; 的错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对第一种情况，可以给 container 加 preStop，让 Pod 真正销毁前先 sleep 等待一段时间，等待 client 所在节点 kube-proxy 更新转发规则，然后再真正去销毁容器。这样能保证在 Pod Terminating 后还能继续正常运行一段时间，这段时间如果因为 client 侧的转发规则更新不及时导致还有新请求转发过来，Pod 还是可以正常处理请求，避免了连接异常的发生。听起来感觉有点不优雅，但实际效果还是比较好的，分布式的世界没有银弹，我们只能尽量在当前设计现状下找到并实践能够解决问题的最优解。&lt;/p&gt;
&lt;p&gt;针对第二种情况，可以给 container 加 ReadinessProbe (就绪检查)，让容器内进程真正启动完成后才更新 Service 的 Endpoint，然后 client 所在节点 kube-proxy 再更新转发规则，让流量进来。这样能够保证等 Pod 完全就绪了才会被转发流量，也就避免了链接异常的发生。&lt;/p&gt;
&lt;p&gt;最佳实践 yaml 示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;        readinessProbe:
          httpGet:
            path: /healthz
            port: 80
            httpHeaders:
            - name: X-Custom-Header
              value: Awesome
          initialDelaySeconds: 10
          timeoutSeconds: 1
        lifecycle:
          preStop:
            exec:
              command: [&amp;quot;/bin/bash&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;sleep 10&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;健康检查怎么配才好&#34;&gt;健康检查怎么配才好？&lt;/h2&gt;
&lt;p&gt;我们都知道，给 Pod 配置健康检查也是提高服务可用性的一种手段，配置 ReadinessProbe (就绪检查) 可以避免将流量转发给还没启动完全或出现异常的 Pod；配置 LivenessProbe (存活检查) 可以让存在 bug 导致死锁或 hang 住的应用重启来恢复。但是，如果配置配置不好，也可能引发其它问题，这里根据一些踩坑经验总结了一些指导性的建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要轻易使用 LivenessProbe，除非你了解后果并且明白为什么你需要它，参考 &lt;a href=&#34;https://srcco.de/posts/kubernetes-liveness-probes-are-dangerous.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Liveness Probes are Dangerous&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果使用 LivenessProbe，不要和 ReadinessProbe 设置成一样 (failureThreshold 更大)&lt;/li&gt;
&lt;li&gt;探测逻辑里不要有外部依赖 (db, 其它 pod 等)，避免抖动导致级联故障&lt;/li&gt;
&lt;li&gt;业务程序应尽量暴露 HTTP 探测接口来适配健康检查，避免使用 TCP 探测，因为程序 hang 死时， TCP 探测仍然能通过 (TCP 的 SYN 包探测端口是否存活在内核态完成，应用层不感知)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Affinity and anti-affinity: &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity&#34;&gt;https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Specifying a Disruption Budget for your Application: &lt;a href=&#34;https://kubernetes.io/docs/tasks/run-application/configure-pdb/&#34;&gt;https://kubernetes.io/docs/tasks/run-application/configure-pdb/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Liveness Probes are Dangerous: &lt;a href=&#34;https://srcco.de/posts/kubernetes-liveness-probes-are-dangerous.html&#34;&gt;https://srcco.de/posts/kubernetes-liveness-probes-are-dangerous.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 服务部署最佳实践(一) 如何合理利用资源</title>
      <link>/post/202006/kubernetes-app-deployment-best-practice-1/</link>
      <pubDate>Tue, 16 Jun 2020 00:00:00 +0000</pubDate>
      <guid>/post/202006/kubernetes-app-deployment-best-practice-1/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#引言&#34;&gt;引言&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#request-与-limit-怎么设置才好&#34;&gt;Request 与 Limit 怎么设置才好&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#所有容器都应该设置-request&#34;&gt;所有容器都应该设置 request&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#老是忘记设置怎么办&#34;&gt;老是忘记设置怎么办&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#重要的线上应用改如何设置&#34;&gt;重要的线上应用改如何设置&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#怎样设置才能提高资源利用率&#34;&gt;怎样设置才能提高资源利用率&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#尽量避免使用过大的-request-与-limit&#34;&gt;尽量避免使用过大的 request 与 limit&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#避免测试-namespace-消耗过多资源影响生产业务&#34;&gt;避免测试 namespace 消耗过多资源影响生产业务&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何让资源得到更合理的分配&#34;&gt;如何让资源得到更合理的分配&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#使用亲和性&#34;&gt;使用亲和性&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#使用污点与容忍&#34;&gt;使用污点与容忍&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#弹性伸缩&#34;&gt;弹性伸缩&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#如何支持流量突发型业务&#34;&gt;如何支持流量突发型业务&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#如何节约成本&#34;&gt;如何节约成本&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#无法水平扩容的服务怎么办&#34;&gt;无法水平扩容的服务怎么办&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#参考资料&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;业务容器化后，如何将其部署在 K8S 上？如果仅仅是将它跑起来，很简单，但如果是上生产，我们有许多地方是需要结合业务场景和部署环境进行方案选型和配置调优的。比如，如何设置容器的 Request 与 Limit、如何让部署的服务做到高可用、如何配置健康检查、如何进行弹性伸缩、如何更好的进行资源调度、如何选择持久化存储、如何对外暴露服务等。&lt;/p&gt;
&lt;p&gt;对于这一系列高频问题，这里将会出一个 Kubernetes 服务部署最佳实践的系列的文章来为大家一一作答，本文将先围绕如何合理利用资源的主题来进行探讨。&lt;/p&gt;
&lt;h2 id=&#34;request-与-limit-怎么设置才好&#34;&gt;Request 与 Limit 怎么设置才好&lt;/h2&gt;
&lt;p&gt;如何为容器配置 Request 与 Limit? 这是一个即常见又棘手的问题，这个根据服务类型，需求与场景的不同而不同，没有固定的答案，这里结合生产经验总结了一些最佳实践，可以作为参考。&lt;/p&gt;
&lt;h3 id=&#34;所有容器都应该设置-request&#34;&gt;所有容器都应该设置 request&lt;/h3&gt;
&lt;p&gt;request 的值并不是指给容器实际分配的资源大小，它仅仅是给调度器看的，调度器会 &amp;ldquo;观察&amp;rdquo; 每个节点可以用于分配的资源有多少，也知道每个节点已经被分配了多少资源。被分配资源的大小就是节点上所有 Pod 中定义的容器 request 之和，它可以计算出节点剩余多少资源可以被分配(可分配资源减去已分配的 request 之和)。如果发现节点剩余可分配资源大小比当前要被调度的 Pod 的 reuqest 还小，那么就不会考虑调度到这个节点，反之，才可能调度。所以，如果不配置 request，那么调度器就不能知道节点大概被分配了多少资源出去，调度器得不到准确信息，也就无法做出合理的调度决策，很容易造成调度不合理，有些节点可能很闲，而有些节点可能很忙，甚至 NotReady。&lt;/p&gt;
&lt;p&gt;所以，建议是给所有容器都设置 request，让调度器感知节点有多少资源被分配了，以便做出合理的调度决策，让集群节点的资源能够被合理的分配使用，避免陷入资源分配不均导致一些意外发生。&lt;/p&gt;
&lt;h3 id=&#34;老是忘记设置怎么办&#34;&gt;老是忘记设置怎么办&lt;/h3&gt;
&lt;p&gt;有时候我们会忘记给部分容器设置 request 与 limit，其实我们可以使用 LimitRange 来设置 namespace 的默认 request 与 limit 值，同时它也可以用来限制最小和最大的 request 与 limit。
示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: LimitRange
metadata:
  name: mem-limit-range
  namespace: test
spec:
  limits:
  - default:
      memory: 512Mi
	  cpu: 500m
    defaultRequest:
      memory: 256Mi
	  cpu: 100m
    type: Container
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;重要的线上应用改如何设置&#34;&gt;重要的线上应用改如何设置&lt;/h3&gt;
&lt;p&gt;节点资源不足时，会触发自动驱逐，将一些低优先级的 Pod 删除掉以释放资源让节点自愈。没有设置 request，limit 的 Pod 优先级最低，容易被驱逐；request 不等于 limit 的其次； request 等于 limit 的 Pod 优先级较高，不容易被驱逐。所以如果是重要的线上应用，不希望在节点故障时被驱逐导致线上业务受影响，就建议将 request 和 limit 设成一致。&lt;/p&gt;
&lt;h3 id=&#34;怎样设置才能提高资源利用率&#34;&gt;怎样设置才能提高资源利用率&lt;/h3&gt;
&lt;p&gt;如果给给你的应用设置较高的 request 值，而实际占用资源长期远小于它的 request 值，导致节点整体的资源利用率较低。当然这对时延非常敏感的业务除外，因为敏感的业务本身不期望节点利用率过高，影响网络包收发速度。所以对一些非核心，并且资源不长期占用的应用，可以适当减少 request 以提高资源利用率。&lt;/p&gt;
&lt;p&gt;如果你的服务支持水平扩容，单副本的 request 值一般可以设置到不大于 1 核，CPU 密集型应用除外。比如 coredns，设置到 0.1 核就可以，即 100m。&lt;/p&gt;
&lt;h3 id=&#34;尽量避免使用过大的-request-与-limit&#34;&gt;尽量避免使用过大的 request 与 limit&lt;/h3&gt;
&lt;p&gt;如果你的服务使用单副本或者少量副本，给很大的 request 与 limit，让它分配到足够多的资源来支撑业务，那么某个副本故障对业务带来的影响可能就比较大，并且由于 request 较大，当集群内资源分配比较碎片化，如果这个 Pod 所在节点挂了，其它节点又没有一个有足够的剩余可分配资源能够满足这个 Pod 的 request 时，这个 Pod 就无法实现漂移，也就不能自愈，加重对业务的影响。&lt;/p&gt;
&lt;p&gt;相反，建议尽量减小 request 与 limit，通过增加副本的方式来对你的服务支撑能力进行水平扩容，让你的系统更加灵活可靠。&lt;/p&gt;
&lt;h3 id=&#34;避免测试-namespace-消耗过多资源影响生产业务&#34;&gt;避免测试 namespace 消耗过多资源影响生产业务&lt;/h3&gt;
&lt;p&gt;若生产集群有用于测试的 namespace，如果不加以限制，可能导致集群负载过高，从而影响生产业务。可以使用 ResourceQuota 来限制测试 namespace 的 request 与 limit 的总大小。
示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ResourceQuota
metadata:
  name: quota-test
  namespace: test
spec:
  hard:
    requests.cpu: &amp;quot;1&amp;quot;
    requests.memory: 1Gi
    limits.cpu: &amp;quot;2&amp;quot;
    limits.memory: 2Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;如何让资源得到更合理的分配&#34;&gt;如何让资源得到更合理的分配&lt;/h2&gt;
&lt;p&gt;设置 Request 能够解决让 Pod 调度到有足够资源的节点上，但无法做到更细致的控制。如何进一步让资源得到合理的使用？我们可以结合亲和性、污点与容忍等高级调度技巧，让 Pod 能够被合理调度到合适的节点上，让资源得到充分的利用。&lt;/p&gt;
&lt;h3 id=&#34;使用亲和性&#34;&gt;使用亲和性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对节点有特殊要求的服务可以用节点亲和性 (Node Affinity) 部署，以便调度到符合要求的节点，比如让 MySQL 调度到高 IO 的机型以提升数据读写效率。&lt;/li&gt;
&lt;li&gt;可以将需要离得比较近的有关联的服务用 Pod 亲和性 (Pod Affinity) 部署，比如让 Web 服务跟它的 Redis 缓存服务都部署在同一可用区，实现低延时。&lt;/li&gt;
&lt;li&gt;也可使用 Pod 反亲和 (Pod AntiAffinity) 将 Pod 进行打散调度，避免单点故障或者流量过于集中导致的一些问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用污点与容忍&#34;&gt;使用污点与容忍&lt;/h3&gt;
&lt;p&gt;使用污点 (Taint) 与容忍 (Toleration) 可优化集群资源调度:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过给节点打污点来给某些应用预留资源，避免其它 Pod 调度上来。&lt;/li&gt;
&lt;li&gt;需要使用这些资源的 Pod 加上容忍，结合节点亲和性让它调度到预留节点，即可使用预留的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;弹性伸缩&#34;&gt;弹性伸缩&lt;/h2&gt;
&lt;h3 id=&#34;如何支持流量突发型业务&#34;&gt;如何支持流量突发型业务&lt;/h3&gt;
&lt;p&gt;通常业务都会有高峰和低谷，为了更合理的利用资源，我们为服务定义 HPA，实现根据 Pod 的资源实际使用情况来对服务进行自动扩缩容，在业务高峰时自动扩容 Pod 数量来支撑服务，在业务低谷时，自动缩容 Pod 释放资源，以供其它服务使用（比如在夜间，线上业务低峰，自动缩容释放资源以供大数据之类的离线任务运行) 。&lt;/p&gt;
&lt;p&gt;使用 HPA 前提是让 K8S 得知道你服务的实际资源占用情况(指标数据)，需要安装 resource metrics (metrics.k8s.io) 或 custom metrics (custom.metrics.k8s.io) 的实现，好让 hpa controller 查询这些 API 来获取到服务的资源占用情况。早期 HPA 用 resource metrics 获取指标数据，后来推出 custom metrics，可以实现更灵活的指标来控制扩缩容。官方有个叫 &lt;a href=&#34;https://github.com/kubernetes-sigs/metrics-server&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;metrics-server&lt;/a&gt; 的实现，通常社区使用的更多的是基于 prometheus 的 实现 &lt;a href=&#34;https://github.com/DirectXMan12/k8s-prometheus-adapter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;prometheus-adapter&lt;/a&gt;，而云厂商托管的 K8S 集群通常集成了自己的实现，比如 TKE，实现了 CPU、内存、硬盘、网络等维度的指标，可以在网页控制台可视化创建 HPA，但最终都会转成 K8S 的 yaml，示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: autoscaling/v2beta2
kind: HorizontalPodAutoscaler
metadata:
  name: nginx
spec:
  scaleTargetRef:
    apiVersion: apps/v1beta2
    kind: Deployment
    name: nginx
  minReplicas: 1
  maxReplicas: 10
  metrics:
  - type: Pods
    pods:
      metric:
        name: k8s_pod_rate_cpu_core_used_request
      target:
        averageValue: &amp;quot;100&amp;quot;
        type: AverageValue
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;如何节约成本&#34;&gt;如何节约成本&lt;/h3&gt;
&lt;p&gt;HPA 能实现 Pod 水平扩缩容，但如果节点资源不够用了，Pod 扩容出来还是会 Pending。如果我们提前准备好大量节点，做好资源冗余，提前准备好大量节点，通常不会有 Pod Pending 的问题，但也意味着需要付出更高的成本。通常云厂商托管的 K8S 集群都会实现 &lt;a href=&#34;https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cluster-autoscaler&lt;/a&gt;，即根据资源使用情况，动态增删节点，让计算资源能够被最大化的弹性使用，按量付费，以节约成本。在 TKE 上的实现叫做伸缩组，以及一个包含伸缩功能组但更高级的特性：节点池(正在灰度)&lt;/p&gt;
&lt;h3 id=&#34;无法水平扩容的服务怎么办&#34;&gt;无法水平扩容的服务怎么办&lt;/h3&gt;
&lt;p&gt;对于无法适配水平伸缩的单体应用，或者不确定最佳 request 与 limit 超卖比的应用，可以尝用 &lt;a href=&#34;https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VPA&lt;/a&gt; 来进行垂直伸缩，即自动更新 request 与 limit，然后重启 pod。不过这个特性容易导致你的服务出现短暂的不可用，不建议在生产环境中大规模使用。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Understanding Kubernetes limits and requests by example: &lt;a href=&#34;https://sysdig.com/blog/kubernetes-limits-requests/&#34;&gt;https://sysdig.com/blog/kubernetes-limits-requests/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Understanding resource limits in kubernetes: cpu time: &lt;a href=&#34;https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-cpu-time-9eff74d3161b&#34;&gt;https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-cpu-time-9eff74d3161b&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Understanding resource limits in kubernetes: memory: &lt;a href=&#34;https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-memory-6b41e9a955f9&#34;&gt;https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-memory-6b41e9a955f9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kubernetes best practices: Resource requests and limits: &lt;a href=&#34;https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-resource-requests-and-limits&#34;&gt;https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-resource-requests-and-limits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kubernetes 资源分配之 Request 和 Limit 解析: &lt;a href=&#34;https://cloud.tencent.com/developer/article/1004976&#34;&gt;https://cloud.tencent.com/developer/article/1004976&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Assign Pods to Nodes using Node Affinity: &lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/&#34;&gt;https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Taints and Tolerations: &lt;a href=&#34;https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/&#34;&gt;https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;metrics-server: &lt;a href=&#34;https://github.com/kubernetes-sigs/metrics-server&#34;&gt;https://github.com/kubernetes-sigs/metrics-server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;prometheus-adapter: &lt;a href=&#34;https://github.com/DirectXMan12/k8s-prometheus-adapter&#34;&gt;https://github.com/DirectXMan12/k8s-prometheus-adapter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cluster-autoscaler: &lt;a href=&#34;https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler&#34;&gt;https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;VPA: &lt;a href=&#34;https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler&#34;&gt;https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>打造云原生大型分布式监控系统(三): Thanos 部署与实践</title>
      <link>/post/202004/build-cloud-native-large-scale-distributed-monitoring-system-3/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      <guid>/post/202004/build-cloud-native-large-scale-distributed-monitoring-system-3/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#视频&#34;&gt;视频&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#概述&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#部署方式&#34;&gt;部署方式&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#方案选型&#34;&gt;方案选型&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#sidecar-or-receiver&#34;&gt;Sidecar or Receiver&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#评估是否需要-ruler&#34;&gt;评估是否需要 Ruler&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#评估是否需要-store-gateway-与-compact&#34;&gt;评估是否需要 Store Gateway 与 Compact&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#部署实践&#34;&gt;部署实践&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#准备对象存储配置&#34;&gt;准备对象存储配置&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#给-prometheus-加上-sidecar&#34;&gt;给 Prometheus 加上 Sidecar&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#安装-query&#34;&gt;安装 Query&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#安装-store-gateway&#34;&gt;安装 Store Gateway&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#安装-ruler&#34;&gt;安装 Ruler&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#安装-compact&#34;&gt;安装 Compact&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#安装-receiver&#34;&gt;安装 Receiver&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#指定-query-为数据源&#34;&gt;指定 Query 为数据源&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#总结&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;视频&#34;&gt;视频&lt;/h2&gt;
&lt;p&gt;附上本系列完整视频&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打造云原生大型分布式监控系统(一): 大规模场景下 Prometheus 的优化手段 &lt;a href=&#34;https://www.bilibili.com/video/BV17C4y1x7HE&#34;&gt;https://www.bilibili.com/video/BV17C4y1x7HE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;打造云原生大型分布式监控系统(二): Thanos 架构详解 &lt;a href=&#34;https://www.bilibili.com/video/BV1Vk4y1R7S9&#34;&gt;https://www.bilibili.com/video/BV1Vk4y1R7S9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;打造云原生大型分布式监控系统(三): Thanos 部署与实践 &lt;a href=&#34;https://www.bilibili.com/video/BV16g4y187HD&#34;&gt;https://www.bilibili.com/video/BV16g4y187HD&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;上一篇 &lt;a href=&#34;../build-cloud-native-large-scale-distributed-monitoring-system-2&#34;&gt;Thanos 架构详解&lt;/a&gt; 我们深入理解了 thanos 的架构设计与实现原理，现在我们来聊聊实战，分享一下如何部署和使用 Thanos。&lt;/p&gt;
&lt;h2 id=&#34;部署方式&#34;&gt;部署方式&lt;/h2&gt;
&lt;p&gt;本文聚焦 Thanos 的云原生部署方式，充分利用 Kubernetes 的资源调度与动态扩容能力。从官方 &lt;a href=&#34;https://thanos.io/getting-started.md/#community-thanos-kubernetes-applications&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt; 可以看到，当前 thanos 在 Kubernetes 上部署有以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coreos/prometheus-operator&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;prometheus-operator&lt;/a&gt;: 集群中安装了 prometheus-operator 后，就可以通过创建 CRD 对象来部署 Thanos 了。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.helm.sh/charts?q=thanos&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;社区贡献的一些 helm charts&lt;/a&gt;: 很多个版本，目标都是能够使用 helm 来一键部署 thanos。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/thanos-io/kube-thanos&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kube-thanos&lt;/a&gt;: Thanos 官方的开源项目，包含部署 thanos 到 kubernetes 的 jsonnet 模板与 yaml 示例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将使用基于 kube-thanos 提供的 yaml 示例 (&lt;code&gt;examples/all/manifests&lt;/code&gt;) 来部署，原因是 prometheus-operator 与社区的 helm chart 方式部署多了一层封装，屏蔽了许多细节，并且它们的实现都还不太成熟；直接使用 kubernetes 的 yaml 资源文件部署更直观，也更容易做自定义，而且我相信使用 thanos 的用户通常都是高玩了，也有必要对 thanos 理解透彻，日后才好根据实际场景做架构和配置的调整，直接使用 yaml 部署能够让我们看清细节。&lt;/p&gt;
&lt;h2 id=&#34;方案选型&#34;&gt;方案选型&lt;/h2&gt;
&lt;h3 id=&#34;sidecar-or-receiver&#34;&gt;Sidecar or Receiver&lt;/h3&gt;
&lt;p&gt;看了上一篇文章的同学应该知道，目前官方的架构图用的 Sidecar 方案，Receiver 是一个暂时还没有完全发布的组件。通常来说，Sidecar 方案相对成熟一些，最新的数据存储和计算 (比如聚合函数) 比较 &amp;ldquo;分布式&amp;rdquo;，更加高效也更容易扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-sidecar.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Receiver 方案是让 Prometheus 通过 remote wirte API 将数据 push 到 Receiver 集中存储 (同样会清理过期数据):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-receiver-without-objectstore.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么该选哪种方案呢？我的建议是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你的 Query 跟 Sidecar 离的比较远，比如 Sidecar 分布在多个数据中心，Query 向所有 Sidecar 查数据，速度会很慢，这种情况可以考虑用 Receiver，将数据集中吐到 Receiver，然后 Receiver 与 Query 部署在一起，Query 直接向 Receiver 查最新数据，提升查询性能。&lt;/li&gt;
&lt;li&gt;如果你的使用场景只允许 Prometheus 将数据 push 到远程，可以考虑使用 Receiver。比如 IoT 设备没有持久化存储，只能将数据 push 到远程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外的场景应该都尽量使用 Sidecar 方案。&lt;/p&gt;
&lt;h3 id=&#34;评估是否需要-ruler&#34;&gt;评估是否需要 Ruler&lt;/h3&gt;
&lt;p&gt;Ruler 是一个可选组件，原则上推荐尽量使用 Prometheus 自带的 rule 功能 (生成新指标+告警)，这个功能需要一些 Prometheus 最新数据，直接使用 Prometheus 本机 rule 功能和数据，性能开销相比 Thanos Ruler 这种分布式方案小得多，并且几乎不会出错，Thanos Ruler 由于是分布式，所以更容易出错一些。&lt;/p&gt;
&lt;p&gt;如果某些有关联的数据分散在多个不同 Prometheus 上，比如对某个大规模服务采集做了分片，每个 Prometheus 仅采集一部分 endpoint 的数据，对于 &lt;code&gt;record&lt;/code&gt; 类型的 rule (生成的新指标)，还是可以使用 Prometheus 自带的 rule 功能，在查询时再聚合一下就可以(如果可以接受的话)；对于 &lt;code&gt;alert&lt;/code&gt; 类型的 rule，就需要用 Thanos Ruler 来做了，因为有关联的数据分散在多个 Prometheus 上，用单机数据去做 alert 计算是不准确的，就可能会造成误告警或不告警。&lt;/p&gt;
&lt;h3 id=&#34;评估是否需要-store-gateway-与-compact&#34;&gt;评估是否需要 Store Gateway 与 Compact&lt;/h3&gt;
&lt;p&gt;Store 也是一个可选组件，也是 Thanos 的一大亮点的关键：数据长期保存。&lt;/p&gt;
&lt;p&gt;评估是否需要 Store 组件实际就是评估一下自己是否有数据长期存储的需求，比如查看一两个月前的监控数据。如果有，那么 Thanos 可以将数据上传到对象存储保存。Thanos 支持以下对象存储:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Cloud Storage&lt;/li&gt;
&lt;li&gt;AWS/S3&lt;/li&gt;
&lt;li&gt;Azure Storage Account&lt;/li&gt;
&lt;li&gt;OpenStack Swift&lt;/li&gt;
&lt;li&gt;Tencent COS&lt;/li&gt;
&lt;li&gt;AliYun OSS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在国内，最方便还是使用腾讯云 COS 或者阿里云 OSS 这样的公有云对象存储服务。如果你的服务没有跑在公有云上，也可以通过跟云服务厂商拉专线的方式来走内网使用对象存储，这样速度通常也是可以满足需求的；如果实在用不了公有云的对象存储服务，也可以自己安装 &lt;a href=&#34;https://github.com/minio/minio&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;minio&lt;/a&gt; 来搭建兼容 AWS 的 S3 对象存储服务。&lt;/p&gt;
&lt;p&gt;搞定了对象存储，还需要给 Thanos 多个组件配置对象存储相关的信息，以便能够上传与读取监控数据。除 Query 以外的所有 Thanos 组件 (Sidecar、Receiver、Ruler、Store Gateway、Compact) 都需要配置对象存储信息，使用 &lt;code&gt;--objstore.config&lt;/code&gt; 直接配置内容或 &lt;code&gt;--objstore.config-file&lt;/code&gt; 引用对象存储配置文件，不同对象存储配置方式不一样，参考官方文档: &lt;a href=&#34;https://thanos.io/storage.md&#34;&gt;https://thanos.io/storage.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通常使用了对象存储来长期保存数据不止要安装 Store Gateway，还需要安装 Compact 来对对象存储里的数据进行压缩与降采样，这样可以提升查询大时间范围监控数据的性能。注意：Compact 并不会减少对象存储的使用空间，而是会增加，增加更长采样间隔的监控数据，这样当查询大时间范围的数据时，就自动拉取更长时间间隔采样的数据以减少查询数据的总量，从而加快查询速度 (大时间范围的数据不需要那么精细)，当放大查看时 (选择其中一小段时间)，又自动选择拉取更短采样间隔的数据，从而也能显示出小时间范围的监控细节。&lt;/p&gt;
&lt;h2 id=&#34;部署实践&#34;&gt;部署实践&lt;/h2&gt;
&lt;p&gt;这里以 Thanos 最新版本为例，选择 Sidecar 方案，介绍各个组件的 k8s yaml 定义方式并解释一些重要细节 (根据自身需求，参考上一节的方案选型，自行评估需要安装哪些组件)。&lt;/p&gt;
&lt;h3 id=&#34;准备对象存储配置&#34;&gt;准备对象存储配置&lt;/h3&gt;
&lt;p&gt;如果我们要使用对象存储来长期保存数据，那么就要准备下对象存储的配置信息 (&lt;code&gt;thanos-objectstorage-secret.yaml&lt;/code&gt;)，比如使用腾讯云 COS 来存储:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Secret
metadata:
  name: thanos-objectstorage
  namespace: thanos
type: Opaque
stringData:
  objectstorage.yaml: |
    type: COS
    config:
      bucket: &amp;quot;thanos&amp;quot;
      region: &amp;quot;ap-singapore&amp;quot;
      app_id: &amp;quot;12*******5&amp;quot;
      secret_key: &amp;quot;tsY***************************Edm&amp;quot;
      secret_id: &amp;quot;AKI******************************gEY&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者使用阿里云 OSS 存储:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Secret
metadata:
  name: thanos-objectstorage
  namespace: thanos
type: Opaque
stringData:
  objectstorage.yaml: |
    type: ALIYUNOSS
    config:
      endpoint: &amp;quot;oss-cn-hangzhou-internal.aliyuncs.com&amp;quot;
      bucket: &amp;quot;thanos&amp;quot;
      access_key_id: &amp;quot;LTA******************KBu&amp;quot;
      access_key_secret: &amp;quot;oki************************2HQ&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注: 对敏感信息打码了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;给-prometheus-加上-sidecar&#34;&gt;给 Prometheus 加上 Sidecar&lt;/h3&gt;
&lt;p&gt;如果选用 Sidecar 方案，就需要给 Prometheus 加上 Thanos Sidecar，准备 &lt;code&gt;prometheus.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;kind: Service
apiVersion: v1
metadata:
  name: prometheus-headless
  namespace: thanos
  labels:
    app.kubernetes.io/name: prometheus
spec:
  type: ClusterIP
  clusterIP: None
  selector:
    app.kubernetes.io/name: prometheus
  ports:
  - name: web
    protocol: TCP
    port: 9090
    targetPort: web
  - name: grpc
    port: 10901
    targetPort: grpc
---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus
  namespace: thanos

---

apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  name: prometheus
  namespace: thanos
rules:
- apiGroups: [&amp;quot;&amp;quot;]
  resources:
  - nodes
  - nodes/proxy
  - nodes/metrics
  - services
  - endpoints
  - pods
  verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;]
- apiGroups: [&amp;quot;&amp;quot;]
  resources: [&amp;quot;configmaps&amp;quot;]
  verbs: [&amp;quot;get&amp;quot;]
- nonResourceURLs: [&amp;quot;/metrics&amp;quot;]
  verbs: [&amp;quot;get&amp;quot;]

---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: prometheus
subjects:
  - kind: ServiceAccount
    name: prometheus
    namespace: thanos
roleRef:
  kind: ClusterRole
  name: prometheus
  apiGroup: rbac.authorization.k8s.io
---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: prometheus
  namespace: thanos
  labels:
    app.kubernetes.io/name: thanos-query
spec:
  serviceName: prometheus-headless
  podManagementPolicy: Parallel
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: prometheus
  template:
    metadata:
      labels:
        app.kubernetes.io/name: prometheus
    spec:
      serviceAccountName: prometheus
      securityContext:
        fsGroup: 2000
        runAsNonRoot: true
        runAsUser: 1000
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                - prometheus
            topologyKey: kubernetes.io/hostname
      containers:
      - name: prometheus
        image: quay.io/prometheus/prometheus:v2.15.2
        args:
        - --config.file=/etc/prometheus/config_out/prometheus.yaml
        - --storage.tsdb.path=/prometheus
        - --storage.tsdb.retention.time=10d
        - --web.route-prefix=/
        - --web.enable-lifecycle
        - --storage.tsdb.no-lockfile
        - --storage.tsdb.min-block-duration=2h
        - --storage.tsdb.max-block-duration=2h
        - --log.level=debug
        ports:
        - containerPort: 9090
          name: web
          protocol: TCP
        livenessProbe:
          failureThreshold: 6
          httpGet:
            path: /-/healthy
            port: web
            scheme: HTTP
          periodSeconds: 5
          successThreshold: 1
          timeoutSeconds: 3
        readinessProbe:
          failureThreshold: 120
          httpGet:
            path: /-/ready
            port: web
            scheme: HTTP
          periodSeconds: 5
          successThreshold: 1
          timeoutSeconds: 3
        volumeMounts:
        - mountPath: /etc/prometheus/config_out
          name: prometheus-config-out
          readOnly: true
        - mountPath: /prometheus
          name: prometheus-storage
        - mountPath: /etc/prometheus/rules
          name: prometheus-rules
      - name: thanos
        image: quay.io/thanos/thanos:v0.11.0
        args:
        - sidecar
        - --log.level=debug
        - --tsdb.path=/prometheus
        - --prometheus.url=http://127.0.0.1:9090
        - --objstore.config-file=/etc/thanos/objectstorage.yaml
        - --reloader.config-file=/etc/prometheus/config/prometheus.yaml.tmpl
        - --reloader.config-envsubst-file=/etc/prometheus/config_out/prometheus.yaml
        - --reloader.rule-dir=/etc/prometheus/rules/
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        ports:
        - name: http-sidecar
          containerPort: 10902
        - name: grpc
          containerPort: 10901
        livenessProbe:
            httpGet:
              port: 10902
              path: /-/healthy
        readinessProbe:
          httpGet:
            port: 10902
            path: /-/ready
        volumeMounts:
        - name: prometheus-config-tmpl
          mountPath: /etc/prometheus/config
        - name: prometheus-config-out
          mountPath: /etc/prometheus/config_out
        - name: prometheus-rules
          mountPath: /etc/prometheus/rules
        - name: prometheus-storage
          mountPath: /prometheus
        - name: thanos-objectstorage
          subPath: objectstorage.yaml
          mountPath: /etc/thanos/objectstorage.yaml
      volumes:
      - name: prometheus-config-tmpl
        configMap:
          defaultMode: 420
          name: prometheus-config-tmpl
      - name: prometheus-config-out
        emptyDir: {}
      - name: prometheus-rules
        configMap:
          name: prometheus-rules
      - name: thanos-objectstorage
        secret:
          secretName: thanos-objectstorage
  volumeClaimTemplates:
  - metadata:
      name: prometheus-storage
      labels:
        app.kubernetes.io/name: prometheus
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 200Gi
      volumeMode: Filesystem
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Prometheus 使用 StatefulSet 方式部署，挂载数据盘以便存储最新监控数据。&lt;/li&gt;
&lt;li&gt;由于 Prometheus 副本之间没有启动顺序的依赖，所以 podManagementPolicy 指定为 Parallel，加快启动速度。&lt;/li&gt;
&lt;li&gt;为 Prometheus 绑定足够的 RBAC 权限，以便后续配置使用 k8s 的服务发现 (&lt;code&gt;kubernetes_sd_configs&lt;/code&gt;) 时能够正常工作。&lt;/li&gt;
&lt;li&gt;为 Prometheus 创建 headless 类型 service，为后续 Thanos Query 通过 DNS SRV 记录来动态发现 Sidecar 的 gRPC 端点做准备 (使用 headless service 才能让 DNS SRV 正确返回所有端点)。&lt;/li&gt;
&lt;li&gt;使用两个 Prometheus 副本，用于实现高可用。&lt;/li&gt;
&lt;li&gt;使用硬反亲和，避免 Prometheus 部署在同一节点，既可以分散压力也可以避免单点故障。&lt;/li&gt;
&lt;li&gt;Prometheus 使用 &lt;code&gt;--storage.tsdb.retention.time&lt;/code&gt; 指定数据保留时长，默认15天，可以根据数据增长速度和数据盘大小做适当调整(数据增长取决于采集的指标和目标端点的数量和采集频率)。&lt;/li&gt;
&lt;li&gt;Sidecar 使用 &lt;code&gt;--objstore.config-file&lt;/code&gt; 引用我们刚刚创建并挂载的对象存储配置文件，用于上传数据到对象存储。&lt;/li&gt;
&lt;li&gt;通常会给 Prometheus 附带一个 quay.io/coreos/prometheus-config-reloader 来监听配置变更并动态加载，但 thanos sidecar 也为我们提供了这个功能，所以可以直接用 thanos sidecar 来实现此功能，也支持配置文件根据模板动态生成：&lt;code&gt;--reloader.config-file&lt;/code&gt; 指定 Prometheus 配置文件模板，&lt;code&gt;--reloader.config-envsubst-file&lt;/code&gt; 指定生成配置文件的存放路径，假设是 &lt;code&gt;/etc/prometheus/config_out/prometheus.yaml&lt;/code&gt; ，那么 &lt;code&gt;/etc/prometheus/config_out&lt;/code&gt; 这个路径使用 emptyDir 让 Prometheus 与 Sidecar 实现配置文件共享挂载，Prometheus 再通过 &lt;code&gt;--config.file&lt;/code&gt; 指定生成出来的配置文件，当配置有更新时，挂载的配置文件也会同步更新，Sidecar 也会通知 Prometheus 重新加载配置。另外，Sidecar 与 Prometheus 也挂载同一份 rules 配置文件，配置更新后 Sidecar 仅通知 Prometheus 加载配置，不支持模板，因为 rules 配置不需要模板来动态生成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后再给 Prometheus 准备配置 (&lt;code&gt;prometheus-config.yaml&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config-tmpl
  namespace: thanos
data:
  prometheus.yaml.tmpl: |-
    global:
      scrape_interval: 5s
      evaluation_interval: 5s
      external_labels:
        cluster: prometheus-ha
        prometheus_replica: $(POD_NAME)
    rule_files:
    - /etc/prometheus/rules/*rules.yaml
    scrape_configs:
    - job_name: cadvisor
      metrics_path: /metrics/cadvisor
      scrape_interval: 10s
      scrape_timeout: 10s
      scheme: https
      tls_config:
        insecure_skip_verify: true
      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      kubernetes_sd_configs:
      - role: node
      relabel_configs:
      - action: labelmap
        regex: __meta_kubernetes_node_label_(.+)
---

apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-rules
  labels:
    name: prometheus-rules
  namespace: thanos
data:
  alert-rules.yaml: |-
    groups:
    - name: k8s.rules
      rules:
      - expr: |
          sum(rate(container_cpu_usage_seconds_total{job=&amp;quot;cadvisor&amp;quot;, image!=&amp;quot;&amp;quot;, container!=&amp;quot;&amp;quot;}[5m])) by (namespace)
        record: namespace:container_cpu_usage_seconds_total:sum_rate
      - expr: |
          sum(container_memory_usage_bytes{job=&amp;quot;cadvisor&amp;quot;, image!=&amp;quot;&amp;quot;, container!=&amp;quot;&amp;quot;}) by (namespace)
        record: namespace:container_memory_usage_bytes:sum
      - expr: |
          sum by (namespace, pod, container) (
            rate(container_cpu_usage_seconds_total{job=&amp;quot;cadvisor&amp;quot;, image!=&amp;quot;&amp;quot;, container!=&amp;quot;&amp;quot;}[5m])
          )
        record: namespace_pod_container:container_cpu_usage_seconds_total:sum_rate
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;本文重点不在 prometheus 的配置文件，所以这里仅以采集 kubelet 所暴露的 cadvisor 容器指标的简单配置为例。&lt;/li&gt;
&lt;li&gt;Prometheus 实例采集的所有指标数据里都会额外加上 &lt;code&gt;external_labels&lt;/code&gt; 里指定的 label，通常用 &lt;code&gt;cluster&lt;/code&gt; 区分当前 Prometheus 所在集群的名称，我们再加了个 &lt;code&gt;prometheus_replica&lt;/code&gt;，用于区分相同 Prometheus 副本（这些副本所采集的数据除了 &lt;code&gt;prometheus_replica&lt;/code&gt; 的值不一样，其它几乎一致，这个值会被 Thanos Sidecar 替换成 Pod 副本的名称，用于 Thanos 实现 Prometheus 高可用）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装-query&#34;&gt;安装 Query&lt;/h3&gt;
&lt;p&gt;准备 &lt;code&gt;thanos-query.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  name: thanos-query
  namespace: thanos
  labels:
    app.kubernetes.io/name: thanos-query
spec:
  ports:
  - name: grpc
    port: 10901
    targetPort: grpc
  - name: http
    port: 9090
    targetPort: http
  selector:
    app.kubernetes.io/name: thanos-query
---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: thanos-query
  namespace: thanos
  labels:
    app.kubernetes.io/name: thanos-query
spec:
  replicas: 3
  selector:
    matchLabels:
      app.kubernetes.io/name: thanos-query
  template:
    metadata:
      labels:
        app.kubernetes.io/name: thanos-query
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app.kubernetes.io/name
                  operator: In
                  values:
                  - thanos-query
              topologyKey: kubernetes.io/hostname
            weight: 100
      containers:
      - args:
        - query
        - --log.level=debug
        - --query.auto-downsampling
        - --grpc-address=0.0.0.0:10901
        - --http-address=0.0.0.0:9090
        - --query.partial-response
        - --query.replica-label=prometheus_replica
        - --query.replica-label=rule_replica
        - --store=dnssrv+_grpc._tcp.prometheus-headless.thanos.svc.cluster.local
        - --store=dnssrv+_grpc._tcp.thanos-rule.thanos.svc.cluster.local
        - --store=dnssrv+_grpc._tcp.thanos-store.thanos.svc.cluster.local
        image: thanosio/thanos:v0.11.0
        livenessProbe:
          failureThreshold: 4
          httpGet:
            path: /-/healthy
            port: 9090
            scheme: HTTP
          periodSeconds: 30
        name: thanos-query
        ports:
        - containerPort: 10901
          name: grpc
        - containerPort: 9090
          name: http
        readinessProbe:
          failureThreshold: 20
          httpGet:
            path: /-/ready
            port: 9090
            scheme: HTTP
          periodSeconds: 5
        terminationMessagePolicy: FallbackToLogsOnError
      terminationGracePeriodSeconds: 120
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;因为 Query 是无状态的，使用 Deployment 部署，也不需要 headless service，直接创建普通的 service。&lt;/li&gt;
&lt;li&gt;使用软反亲和，尽量不让 Query 调度到同一节点。&lt;/li&gt;
&lt;li&gt;部署多个副本，实现 Query 的高可用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--query.partial-response&lt;/code&gt; 启用 &lt;a href=&#34;https://thanos.io/components/query.md/#partial-response&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Partial Response&lt;/a&gt;，这样可以在部分后端 Store API 返回错误或超时的情况下也能看到正确的监控数据(如果后端 Store API 做了高可用，挂掉一个副本，Query 访问挂掉的副本超时，但由于还有没挂掉的副本，还是能正确返回结果；如果挂掉的某个后端本身就不存在我们需要的数据，挂掉也不影响结果的正确性；总之如果各个组件都做了高可用，想获得错误的结果都难，所以我们有信心启用 Partial Response 这个功能)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--query.auto-downsampling&lt;/code&gt; 查询时自动降采样，提升查询效率。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--query.replica-label&lt;/code&gt; 指定我们刚刚给 Prometheus 配置的 &lt;code&gt;prometheus_replica&lt;/code&gt; 这个 external label，Query 向 Sidecar 拉取 Prometheus 数据时会识别这个 label 并自动去重，这样即使挂掉一个副本，只要至少有一个副本正常也不会影响查询结果，也就是可以实现 Prometheus 的高可用。同理，再指定一个 &lt;code&gt;rule_replica&lt;/code&gt; 用于给 Ruler 做高可用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--store&lt;/code&gt; 指定实现了 Store API 的地址(Sidecar, Ruler, Store Gateway, Receiver)，通常不建议写静态地址，而是使用服务发现机制自动发现 Store API 地址，如果是部署在同一个集群，可以用 DNS SRV 记录来做服务发现，比如 &lt;code&gt;dnssrv+_grpc._tcp.prometheus-headless.thanos.svc.cluster.local&lt;/code&gt;，也就是我们刚刚为包含 Sidecar 的 Prometheus 创建的 headless service (使用 headless service 才能正确实现服务发现)，并且指定了名为 grpc 的 tcp 端口，同理，其它组件也可以按照这样加到 &lt;code&gt;--store&lt;/code&gt; 参数里；如果是其它有些组件部署在集群外，无法通过集群 dns 解析 DNS SRV 记录，可以使用配置文件来做服务发现，也就是指定 &lt;code&gt;--store.sd-files&lt;/code&gt; 参数，将其它 Store API 地址写在配置文件里 (挂载 ConfigMap)，需要增加地址时直接更新 ConfigMap (不需要重启 Query)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装-store-gateway&#34;&gt;安装 Store Gateway&lt;/h3&gt;
&lt;p&gt;准备 &lt;code&gt;thanos-store.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  name: thanos-store
  namespace: thanos
  labels:
    app.kubernetes.io/name: thanos-store
spec:
  clusterIP: None
  ports:
  - name: grpc
    port: 10901
    targetPort: 10901
  - name: http
    port: 10902
    targetPort: 10902
  selector:
    app.kubernetes.io/name: thanos-store
---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: thanos-store
  namespace: thanos
  labels:
    app.kubernetes.io/name: thanos-store
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: thanos-store
  serviceName: thanos-store
  podManagementPolicy: Parallel
  template:
    metadata:
      labels:
        app.kubernetes.io/name: thanos-store
    spec:
      containers:
      - args:
        - store
        - --log.level=debug
        - --data-dir=/var/thanos/store
        - --grpc-address=0.0.0.0:10901
        - --http-address=0.0.0.0:10902
        - --objstore.config-file=/etc/thanos/objectstorage.yaml
        - --experimental.enable-index-header
        image: thanosio/thanos:v0.11.0
        livenessProbe:
          failureThreshold: 8
          httpGet:
            path: /-/healthy
            port: 10902
            scheme: HTTP
          periodSeconds: 30
        name: thanos-store
        ports:
        - containerPort: 10901
          name: grpc
        - containerPort: 10902
          name: http
        readinessProbe:
          failureThreshold: 20
          httpGet:
            path: /-/ready
            port: 10902
            scheme: HTTP
          periodSeconds: 5
        terminationMessagePolicy: FallbackToLogsOnError
        volumeMounts:
        - mountPath: /var/thanos/store
          name: data
          readOnly: false
        - name: thanos-objectstorage
          subPath: objectstorage.yaml
          mountPath: /etc/thanos/objectstorage.yaml
      terminationGracePeriodSeconds: 120
      volumes:
      - name: thanos-objectstorage
        secret:
          secretName: thanos-objectstorage
  volumeClaimTemplates:
  - metadata:
      labels:
        app.kubernetes.io/name: thanos-store
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 10Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Store Gateway 实际也可以做到一定程度的无状态，它会需要一点磁盘空间来对对象存储做索引以加速查询，但数据不那么重要，是可以删除的，删除后会自动去拉对象存储查数据重新建立索引。这里我们避免每次重启都重新建立索引，所以用 StatefulSet 部署 Store Gateway，挂载一块小容量的磁盘(索引占用不到多大空间)。&lt;/li&gt;
&lt;li&gt;同样创建 headless service，用于 Query 对 Store Gateway 进行服务发现。&lt;/li&gt;
&lt;li&gt;部署两个副本，实现 Store Gateway 的高可用。&lt;/li&gt;
&lt;li&gt;Store Gateway 也需要对象存储的配置，用于读取对象存储的数据，所以要挂载对象存储的配置文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装-ruler&#34;&gt;安装 Ruler&lt;/h3&gt;
&lt;p&gt;准备 Ruler 部署配置 &lt;code&gt;thanos-ruler.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/name: thanos-rule
  name: thanos-rule
  namespace: thanos
spec:
  clusterIP: None
  ports:
  - name: grpc
    port: 10901
    targetPort: grpc
  - name: http
    port: 10902
    targetPort: http
  selector:
    app.kubernetes.io/name: thanos-rule
---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app.kubernetes.io/name: thanos-rule
  name: thanos-rule
  namespace: thanos
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: thanos-rule
  serviceName: thanos-rule
  podManagementPolicy: Parallel
  template:
    metadata:
      labels:
        app.kubernetes.io/name: thanos-rule
    spec:
      containers:
      - args:
        - rule
        - --grpc-address=0.0.0.0:10901
        - --http-address=0.0.0.0:10902
        - --rule-file=/etc/thanos/rules/*rules.yaml
        - --objstore.config-file=/etc/thanos/objectstorage.yaml
        - --data-dir=/var/thanos/rule
        - --label=rule_replica=&amp;quot;$(NAME)&amp;quot;
        - --alert.label-drop=&amp;quot;rule_replica&amp;quot;
        - --query=dnssrv+_http._tcp.thanos-query.thanos.svc.cluster.local
        env:
        - name: NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        image: thanosio/thanos:v0.11.0
        livenessProbe:
          failureThreshold: 24
          httpGet:
            path: /-/healthy
            port: 10902
            scheme: HTTP
          periodSeconds: 5
        name: thanos-rule
        ports:
        - containerPort: 10901
          name: grpc
        - containerPort: 10902
          name: http
        readinessProbe:
          failureThreshold: 18
          httpGet:
            path: /-/ready
            port: 10902
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 5
        terminationMessagePolicy: FallbackToLogsOnError
        volumeMounts:
        - mountPath: /var/thanos/rule
          name: data
          readOnly: false
        - name: thanos-objectstorage
          subPath: objectstorage.yaml
          mountPath: /etc/thanos/objectstorage.yaml
        - name: thanos-rules
          mountPath: /etc/thanos/rules
      volumes:
      - name: thanos-objectstorage
        secret:
          secretName: thanos-objectstorage
      - name: thanos-rules
        configMap:
          name: thanos-rules
  volumeClaimTemplates:
  - metadata:
      labels:
        app.kubernetes.io/name: thanos-rule
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 100Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Ruler 是有状态服务，使用 Statefulset 部署，挂载磁盘以便存储根据 rule 配置计算出的新数据。&lt;/li&gt;
&lt;li&gt;同样创建 headless service，用于 Query 对 Ruler 进行服务发现。&lt;/li&gt;
&lt;li&gt;部署两个副本，且使用 &lt;code&gt;--label=rule_replica=&lt;/code&gt; 给所有数据添加 &lt;code&gt;rule_replica&lt;/code&gt; 的 label (与 Query 配置的 &lt;code&gt;replica_label&lt;/code&gt; 相呼应)，用于实现 Ruler 高可用。同时指定 &lt;code&gt;--alert.label-drop&lt;/code&gt; 为 &lt;code&gt;rule_replica&lt;/code&gt;，在触发告警发送通知给 AlertManager 时，去掉这个 label，以便让 AlertManager 自动去重 (避免重复告警)。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;--query&lt;/code&gt; 指定 Query 地址，这里还是用 DNS SRV 来做服务发现，但效果跟配 &lt;code&gt;dns+thanos-query.thanos.svc.cluster.local:9090&lt;/code&gt; 是一样的，最终都是通过 Query 的 ClusterIP (VIP) 访问，因为它是无状态的，可以直接由 K8S 来给我们做负载均衡。&lt;/li&gt;
&lt;li&gt;Ruler 也需要对象存储的配置，用于上传计算出的数据到对象存储，所以要挂载对象存储的配置文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--rule-file&lt;/code&gt; 指定挂载的 rule 配置，Ruler 根据配置来生成数据和触发告警。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再准备 Ruler 配置文件 &lt;code&gt;thanos-ruler-config.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: thanos-rules
  labels:
    name: thanos-rules
  namespace: thanos
data:
  record.rules.yaml: |-
    groups:
    - name: k8s.rules
      rules:
      - expr: |
          sum(rate(container_cpu_usage_seconds_total{job=&amp;quot;cadvisor&amp;quot;, image!=&amp;quot;&amp;quot;, container!=&amp;quot;&amp;quot;}[5m])) by (namespace)
        record: namespace:container_cpu_usage_seconds_total:sum_rate
      - expr: |
          sum(container_memory_usage_bytes{job=&amp;quot;cadvisor&amp;quot;, image!=&amp;quot;&amp;quot;, container!=&amp;quot;&amp;quot;}) by (namespace)
        record: namespace:container_memory_usage_bytes:sum
      - expr: |
          sum by (namespace, pod, container) (
            rate(container_cpu_usage_seconds_total{job=&amp;quot;cadvisor&amp;quot;, image!=&amp;quot;&amp;quot;, container!=&amp;quot;&amp;quot;}[5m])
          )
        record: namespace_pod_container:container_cpu_usage_seconds_total:sum_rate
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;配置内容仅为示例，根据自身情况来配置，格式基本兼容 Prometheus 的 rule 配置格式，参考: &lt;a href=&#34;https://thanos.io/components/rule.md/#configuring-rules&#34;&gt;https://thanos.io/components/rule.md/#configuring-rules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装-compact&#34;&gt;安装 Compact&lt;/h3&gt;
&lt;p&gt;准备 Compact 部署配置 &lt;code&gt;thanos-compact.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/name: thanos-compact
  name: thanos-compact
  namespace: thanos
spec:
  ports:
  - name: http
    port: 10902
    targetPort: http
  selector:
    app.kubernetes.io/name: thanos-compact
---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app.kubernetes.io/name: thanos-compact
  name: thanos-compact
  namespace: thanos
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: thanos-compact
  serviceName: thanos-compact
  template:
    metadata:
      labels:
        app.kubernetes.io/name: thanos-compact
    spec:
      containers:
      - args:
        - compact
        - --wait
        - --objstore.config-file=/etc/thanos/objectstorage.yaml
        - --data-dir=/var/thanos/compact
        - --debug.accept-malformed-index
        - --log.level=debug
        - --retention.resolution-raw=90d
        - --retention.resolution-5m=180d
        - --retention.resolution-1h=360d
        image: thanosio/thanos:v0.11.0
        livenessProbe:
          failureThreshold: 4
          httpGet:
            path: /-/healthy
            port: 10902
            scheme: HTTP
          periodSeconds: 30
        name: thanos-compact
        ports:
        - containerPort: 10902
          name: http
        readinessProbe:
          failureThreshold: 20
          httpGet:
            path: /-/ready
            port: 10902
            scheme: HTTP
          periodSeconds: 5
        terminationMessagePolicy: FallbackToLogsOnError
        volumeMounts:
        - mountPath: /var/thanos/compact
          name: data
          readOnly: false
        - name: thanos-objectstorage
          subPath: objectstorage.yaml
          mountPath: /etc/thanos/objectstorage.yaml
      terminationGracePeriodSeconds: 120
      volumes:
      - name: thanos-objectstorage
        secret:
          secretName: thanos-objectstorage
  volumeClaimTemplates:
  - metadata:
      labels:
        app.kubernetes.io/name: thanos-compact
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 100Gi

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Compact 只能部署单个副本，因为如果多个副本都去对对象存储的数据做压缩和降采样的话，会造成冲突。&lt;/li&gt;
&lt;li&gt;使用 StatefulSet 部署，方便自动创建和挂载磁盘。磁盘用于存放临时数据，因为 Compact 需要一些磁盘空间来存放数据处理过程中产生的中间数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--wait&lt;/code&gt; 让 Compact 一直运行，轮询新数据来做压缩和降采样。&lt;/li&gt;
&lt;li&gt;Compact 也需要对象存储的配置，用于读取对象存储数据以及上传压缩和降采样后的数据到对象存储。&lt;/li&gt;
&lt;li&gt;创建一个普通 service，主要用于被 Prometheus 使用 kubernetes 的 endpoints 服务发现来采集指标(其它组件的 service 也一样有这个用途)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--retention.resolution-raw&lt;/code&gt; 指定原始数据存放时长，&lt;code&gt;--retention.resolution-5m&lt;/code&gt; 指定降采样到数据点 5 分钟间隔的数据存放时长，&lt;code&gt;--retention.resolution-1h&lt;/code&gt; 指定降采样到数据点 1 小时间隔的数据存放时长，它们的数据精细程度递减，占用的存储空间也是递减，通常建议它们的存放时间递增配置 (一般只有比较新的数据才会放大看，久远的数据通常只会使用大时间范围查询来看个大致，所以建议将精细程度低的数据存放更长时间)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装-receiver&#34;&gt;安装 Receiver&lt;/h3&gt;
&lt;p&gt;该组件处于试验阶段，慎用。准备 Receiver 部署配置 &lt;code&gt;thanos-receiver.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: thanos-receive-hashrings
  namespace: thanos
data:
  thanos-receive-hashrings.json: |
    [
      {
        &amp;quot;hashring&amp;quot;: &amp;quot;soft-tenants&amp;quot;,
        &amp;quot;endpoints&amp;quot;:
        [
          &amp;quot;thanos-receive-0.thanos-receive.kube-system.svc.cluster.local:10901&amp;quot;,
          &amp;quot;thanos-receive-1.thanos-receive.kube-system.svc.cluster.local:10901&amp;quot;,
          &amp;quot;thanos-receive-2.thanos-receive.kube-system.svc.cluster.local:10901&amp;quot;
        ]
      }
    ]
---

apiVersion: v1
kind: Service
metadata:
  name: thanos-receive
  namespace: thanos
  labels:
    kubernetes.io/name: thanos-receive
spec:
  ports:
  - name: http
    port: 10902
    protocol: TCP
    targetPort: 10902
  - name: remote-write
    port: 19291
    protocol: TCP
    targetPort: 19291
  - name: grpc
    port: 10901
    protocol: TCP
    targetPort: 10901
  selector:
    kubernetes.io/name: thanos-receive
  clusterIP: None
---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    kubernetes.io/name: thanos-receive
  name: thanos-receive
  namespace: thanos
spec:
  replicas: 3
  selector:
    matchLabels:
      kubernetes.io/name: thanos-receive
  serviceName: thanos-receive
  template:
    metadata:
      labels:
        kubernetes.io/name: thanos-receive
    spec:
      containers:
      - args:
        - receive
        - --grpc-address=0.0.0.0:10901
        - --http-address=0.0.0.0:10902
        - --remote-write.address=0.0.0.0:19291
        - --objstore.config-file=/etc/thanos/objectstorage.yaml
        - --tsdb.path=/var/thanos/receive
        - --tsdb.retention=12h
        - --label=receive_replica=&amp;quot;$(NAME)&amp;quot;
        - --label=receive=&amp;quot;true&amp;quot;
        - --receive.hashrings-file=/etc/thanos/thanos-receive-hashrings.json
        - --receive.local-endpoint=$(NAME).thanos-receive.thanos.svc.cluster.local:10901
        env:
        - name: NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        image: thanosio/thanos:v0.11.0
        livenessProbe:
          failureThreshold: 4
          httpGet:
            path: /-/healthy
            port: 10902
            scheme: HTTP
          periodSeconds: 30
        name: thanos-receive
        ports:
        - containerPort: 10901
          name: grpc
        - containerPort: 10902
          name: http
        - containerPort: 19291
          name: remote-write
        readinessProbe:
          httpGet:
            path: /-/ready
            port: 10902
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 30
        resources:
          limits:
            cpu: &amp;quot;4&amp;quot;
            memory: 8Gi
          requests:
            cpu: &amp;quot;2&amp;quot;
            memory: 4Gi
        volumeMounts:
        - mountPath: /var/thanos/receive
          name: data
          readOnly: false
        - mountPath: /etc/thanos/thanos-receive-hashrings.json
          name: thanos-receive-hashrings
          subPath: thanos-receive-hashrings.json
        - mountPath: /etc/thanos/objectstorage.yaml
          name: thanos-objectstorage
          subPath: objectstorage.yaml
      terminationGracePeriodSeconds: 120
      volumes:
      - configMap:
          defaultMode: 420
          name: thanos-receive-hashrings
        name: thanos-receive-hashrings
      - name: thanos-objectstorage
        secret:
          secretName: thanos-objectstorage
  volumeClaimTemplates:
  - metadata:
      labels:
        app.kubernetes.io/name: thanos-receive
      name: data
    spec:
      accessModes:
      - ReadWriteOnce
      resources:
        requests:
          storage: 200Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;部署 3 个副本， 配置 hashring， &lt;code&gt;--label=receive_replica&lt;/code&gt; 为数据添加 &lt;code&gt;receive_replica&lt;/code&gt; 这个 label (Query 的 &lt;code&gt;--query.replica-label&lt;/code&gt; 也要加上这个) 来实现 Receiver 的高可用。&lt;/li&gt;
&lt;li&gt;Query 要指定 Receiver 后端地址: &lt;code&gt;--store=dnssrv+_grpc._tcp.thanos-receive.thanos.svc.cluster.local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;request, limit 根据自身规模情况自行做适当调整。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--tsdb.retention&lt;/code&gt; 根据自身需求调整最新数据的保留时间。&lt;/li&gt;
&lt;li&gt;如果改命名空间，记得把 Receiver 的 &lt;code&gt;--receive.local-endpoint&lt;/code&gt; 参数也改下，不然会疯狂报错直至 OOMKilled。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为使用了 Receiver 来统一接收 Prometheus 的数据，所以 Prometheus 也不需要 Sidecar 了，但需要给 Prometheus 配置文件里加下 &lt;code&gt;remote_write&lt;/code&gt;，让 Prometheus 将数据 push 给 Receiver:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    remote_write:
    - url: http://thanos-receive.thanos.svc.cluster.local:19291/api/v1/receive
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指定-query-为数据源&#34;&gt;指定 Query 为数据源&lt;/h3&gt;
&lt;p&gt;查询监控数据时需要指定 Prometheus 数据源地址，由于我们使用了 Thanos 来做分布式，而 Thanos 关键查询入口就是 Query，所以我们需要将数据源地址指定为 Query 的地址，假如使用 Grafana 查询，进入 &lt;code&gt;Configuration&lt;/code&gt;-&lt;code&gt;Data Sources&lt;/code&gt;-&lt;code&gt;Add data source&lt;/code&gt;，选择 Prometheus，指定 thanos query 的地址: &lt;code&gt;http://thanos-query.thanos.svc.cluster.local:9090&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文教了大家如何选型 Thanos 部署方案并详细讲解了各个组件的安装方法，如果仔细阅读完本系列文章，我相信你已经有能力搭建并运维一套大型监控系统了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>打造云原生大型分布式监控系统(二): Thanos 架构详解</title>
      <link>/post/202004/build-cloud-native-large-scale-distributed-monitoring-system-2/</link>
      <pubDate>Mon, 06 Apr 2020 13:50:00 +0800</pubDate>
      <guid>/post/202004/build-cloud-native-large-scale-distributed-monitoring-system-2/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#概述&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#thanos-架构&#34;&gt;Thanos 架构&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#架构设计剖析&#34;&gt;架构设计剖析&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#query-与-sidecar&#34;&gt;Query 与 Sidecar&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#store-gateway&#34;&gt;Store Gateway&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#ruler&#34;&gt;Ruler&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#compact&#34;&gt;Compact&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#再看架构图&#34;&gt;再看架构图&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#sidecar-模式与-receiver-模式&#34;&gt;Sidecar 模式与 Receiver 模式&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#总结&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;之前在 &lt;a href=&#34;../../202003/build-cloud-native-large-scale-distributed-monitoring-system-1&#34;&gt;大规模场景下 Prometheus 的优化手段&lt;/a&gt; 中，我们想尽 &amp;ldquo;千方百计&amp;rdquo; 才好不容易把 Prometheus 优化到适配大规模场景，部署和后期维护麻烦且复杂不说，还有很多不完美的地方，并且还无法满足一些更高级的诉求，比如查看时间久远的监控数据，对于一些时间久远不常用的 &amp;ldquo;冷数据&amp;rdquo;，最理想的方式就是存到廉价的对象存储中，等需要查询的时候能够自动加载出来。&lt;/p&gt;
&lt;p&gt;Thanos (没错，就是灭霸) 可以帮我们简化分布式 Prometheus 的部署与管理，并提供了一些的高级特性：&lt;strong&gt;全局视图&lt;/strong&gt;，&lt;strong&gt;长期存储&lt;/strong&gt;，&lt;strong&gt;高可用&lt;/strong&gt;。下面我们来详细讲解一下。&lt;/p&gt;
&lt;h2 id=&#34;thanos-架构&#34;&gt;Thanos 架构&lt;/h2&gt;
&lt;p&gt;这是官方给出的架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-arch.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这张图中包含了 Thanos 的几个核心组件，但并不包括所有组件，为了便于理解，我们先不细讲，简单介绍下图中这几个组件的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Thanos Query: 实现了 Prometheus API，将来自下游组件提供的数据进行聚合最终返回给查询数据的 client (如 grafana)，类似数据库中间件。&lt;/li&gt;
&lt;li&gt;Thanos Sidecar: 连接 Prometheus，将其数据提供给 Thanos Query 查询，并且/或者将其上传到对象存储，以供长期存储。&lt;/li&gt;
&lt;li&gt;Thanos Store Gateway: 将对象存储的数据暴露给 Thanos Query 去查询。&lt;/li&gt;
&lt;li&gt;Thanos Ruler: 对监控数据进行评估和告警，还可以计算出新的监控数据，将这些新数据提供给 Thanos Query 查询并且/或者上传到对象存储，以供长期存储。&lt;/li&gt;
&lt;li&gt;Thanos Compact: 将对象存储中的数据进行压缩和降低采样率，加速大时间区间监控数据查询的速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;架构设计剖析&#34;&gt;架构设计剖析&lt;/h2&gt;
&lt;p&gt;如何理解 Thanos 的架构设计的？我们可以自己先 YY 一下，要是自己来设计一个分布式 Prometheus 管理应用，会怎么做？&lt;/p&gt;
&lt;h3 id=&#34;query-与-sidecar&#34;&gt;Query 与 Sidecar&lt;/h3&gt;
&lt;p&gt;首先，监控数据的查询肯定不能直接查 Prometheus 了，因为会存在许多个 Prometheus 实例，每个 Prometheus 实例只能感知它自己所采集的数据。我们可以比较容易联想到数据库中间件，每个数据库都只存了一部分数据，中间件能感知到所有数据库，数据查询都经过数据库中间件来查，这个中间件收到查询请求再去查下游各个数据库中的数据，最后将这些数据聚合汇总返回给查询的客户端，这样就实现了将分布式存储的数据集中查询。&lt;/p&gt;
&lt;p&gt;实际上，Thanos 也是使用了类似的设计思想，Thanos Query 就是这个 &amp;ldquo;中间件&amp;rdquo; 的关键入口。它实现了 Prometheus 的 HTTP API，能够 &amp;ldquo;看懂&amp;rdquo; PromQL。这样，查询 Prometheus 监控数据的 client 就不直接查询 Prometheus 本身了，而是去查询 Thanos Query，Thanos Query 再去下游多个存储了数据的地方查数据，最后将这些数据聚合去重后返回给 client，也就实现了分布式 Prometheus 的数据查询。&lt;/p&gt;
&lt;p&gt;那么 Thanos Query 又如何去查下游分散的数据呢？Thanos 为此抽象了一套叫 Store API 的内部 gRPC 接口，其它一些组件通过这个接口来暴露数据给 Thanos Query，它自身也就可以做到完全无状态部署，实现高可用与动态扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-querier.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这些分散的数据可能来自哪些地方呢？首先，Prometheus 会将采集的数据存到本机磁盘上，如果我们直接用这些分散在各个磁盘上的数据，可以给每个 Prometheus 附带部署一个 Sidecar，这个 Sidecar 实现 Thanos Store API，当 Thanos Query 对其发起查询时，Sidecar 就读取跟它绑定部署的 Prometheus 实例上的监控数据返回给 Thanos Query。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-sidecar.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于 Thanos Query 可以对数据进行聚合与去重，所以可以很轻松实现高可用：相同的 Prometheus 部署多个副本(都附带 Sidecar)，然后 Thanos Query 去所有 Sidecar 查数据，即便有一个 Prometheus 实例挂掉过一段时间，数据聚合与去重后仍然能得到完整数据。&lt;/p&gt;
&lt;p&gt;这种高可用做法还弥补了我们上篇文章中用负载均衡去实现 Prometheus 高可用方法的缺陷：如果其中一个 Prometheus 实例挂了一段时间然后又恢复了，它的数据就不完整，当负载均衡转发到它上面去查数据时，返回的结果就可能会有部分缺失。&lt;/p&gt;
&lt;p&gt;不过因为磁盘空间有限，所以 Prometheus 存储监控数据的能力也是有限的，通常会给 Prometheus 设置一个数据过期时间 (默认15天) 或者最大数据量大小，不断清理旧数据以保证磁盘不被撑爆。因此，我们无法看到时间比较久远的监控数据，有时候这也给我们的问题排查和数据统计造成一些困难。&lt;/p&gt;
&lt;p&gt;对于需要长期存储的数据，并且使用频率不那么高，最理想的方式是存进对象存储，各大云厂商都有对象存储服务，特点是不限制容量，价格非常便宜。&lt;/p&gt;
&lt;p&gt;Thanos 有几个组件都支持将数据上传到各种对象存储以供长期保存 (Prometheus TSDB 数据格式)，比如我们刚刚说的 Sidecar:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-sidecar-with-objectstore.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;store-gateway&#34;&gt;Store Gateway&lt;/h3&gt;
&lt;p&gt;那么这些被上传到了对象存储里的监控数据该如何查询呢？理论上 Thanos Query 也可以直接去对象存储查，但会让 Thanos Query 的逻辑变的很重。我们刚才也看到了，Thanos 抽象出了 Store API，只要实现了该接口的组件都可以作为 Thanos Query 查询的数据源，Thanos Store Gateway 这个组件也实现了 Store API，向 Thanos Query 暴露对象存储的数据。Thanos Store Gateway 内部还做了一些加速数据获取的优化逻辑，一是缓存了 TSDB 索引，二是优化了对象存储的请求 (用尽可能少的请求量拿到所有需要的数据)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-store-gateway.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这样就实现了监控数据的长期储存，由于对象存储容量无限，所以理论上我们可以存任意时长的数据，监控历史数据也就变得可追溯查询，便于问题排查与统计分析。&lt;/p&gt;
&lt;h3 id=&#34;ruler&#34;&gt;Ruler&lt;/h3&gt;
&lt;p&gt;有一个问题，Prometheus 不仅仅只支持将采集的数据进行存储和查询的功能，还可以配置一些 rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据配置不断计算出新指标数据并存储，后续查询时直接使用计算好的新指标，这样可以减轻查询时的计算压力，加快查询速度。&lt;/li&gt;
&lt;li&gt;不断计算和评估是否达到告警阀值，当达到阀值时就通知 AlertManager 来触发告警。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于我们将 Prometheus 进行分布式部署，每个 Prometheus 实例本地并没有完整数据，有些有关联的数据可能存在多个 Prometheus 实例中，单机 Prometheus 看不到数据的全局视图，这种情况我们就不能依赖 Prometheus 来做这些工作，Thanos Ruler 应运而生，它通过查询 Thanos Query 获取全局数据，然后根据 rules 配置计算新指标并存储，同时也通过 Store API 将数据暴露给 Thanos Query，同样还可以将数据上传到对象存储以供长期保存 (这里上传到对象存储中的数据一样也是通过 Thanos Store Gateway 暴露给 Thanos Query)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-ruler.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;看起来 Thanos Query 跟 Thanos Ruler 之间会相互查询，不过这个不冲突，Thanos Ruler 为 Thanos Query 提供计算出的新指标数据，而 Thanos Query 为 Thanos Ruler 提供计算新指标所需要的全局原始指标数据。&lt;/p&gt;
&lt;p&gt;至此，Thanos 的核心能力基本实现了，完全兼容 Prometheus 的情况下提供数据查询的全局视图，高可用以及数据的长期保存。&lt;/p&gt;
&lt;p&gt;看下还可以怎么进一步做下优化呢？&lt;/p&gt;
&lt;h3 id=&#34;compact&#34;&gt;Compact&lt;/h3&gt;
&lt;p&gt;由于我们有数据长期存储的能力，也就可以实现查询较大时间范围的监控数据，当时间范围很大时，查询的数据量也会很大，这会导致查询速度非常慢。通常在查看较大时间范围的监控数据时，我们并不需要那么详细的数据，只需要看到大致就行。Thanos Compact 这个组件应运而生，它读取对象存储的数据，对其进行压缩以及降采样再上传到对象存储，这样在查询大时间范围数据时就可以只读取压缩和降采样后的数据，极大地减少了查询的数据量，从而加速查询。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-compact.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;再看架构图&#34;&gt;再看架构图&lt;/h3&gt;
&lt;p&gt;上面我们剖析了官方架构图中各个组件的设计，现在再来回味一下这张图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-arch.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;理解是否更加深刻了？&lt;/p&gt;
&lt;p&gt;另外还有 Thanos Bucket 和 Thanos Checker 两个辅助性的工具组件没画出来，它们不是核心组件，这里也就不再赘述。&lt;/p&gt;
&lt;h2 id=&#34;sidecar-模式与-receiver-模式&#34;&gt;Sidecar 模式与 Receiver 模式&lt;/h2&gt;
&lt;p&gt;前面我们理解了官方的架构图，但其中还缺失一个核心组件 Thanos Receiver，因为它是一个还未完全发布的组件。这是它的设计文档: &lt;a href=&#34;https://thanos.io/proposals/201812_thanos-remote-receive.md/&#34;&gt;https://thanos.io/proposals/201812_thanos-remote-receive.md/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个组件可以完全消除 Sidecar，所以 Thanos 实际有两种架构图，只是因为没有完全发布，官方的架构图只给的 Sidecar 模式。&lt;/p&gt;
&lt;p&gt;Receiver 是做什么的呢？为什么需要 Receiver？它跟 Sidecar 有什么区别？&lt;/p&gt;
&lt;p&gt;它们都可以将数据上传到对象存储以供长期保存，区别在于最新数据的存储。&lt;/p&gt;
&lt;p&gt;由于数据上传不可能实时，Sidecar 模式将最新的监控数据存到 Prometheus 本机，Query 通过调所有 Sidecar 的 Store API 来获取最新数据，这就成一个问题：如果 Sidecar 数量非常多或者 Sidecar 跟 Query 离的比较远，每次查询 Query 都调所有 Sidecar 会消耗很多资源，并且速度很慢，而我们查看监控大多数情况都是看的最新数据。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，Thanos Receiver 组件被提出，它适配了 Prometheus 的 remote write API，也就是所有 Prometheus 实例可以实时将数据 push 到 Thanos Receiver，最新数据也得以集中起来，然后 Thanos Query 也不用去所有 Sidecar 查最新数据了，直接查 Thanos Receiver 即可。另外，Thanos Receiver 也将数据上传到对象存储以供长期保存，当然，对象存储中的数据同样由 Thanos Store Gateway 暴露给 Thanos Query。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/thanos-receiver.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;有同学可能会问：如果规模很大，Receiver 压力会不会很大，成为性能瓶颈？当然设计这个组件时肯定会考虑这个问题，Receiver 实现了一致性哈希，支持集群部署，所以即使规模很大也不会成为性能瓶颈。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文详细讲解了 Thanos 的架构设计，各个组件的作用以及为什么要这么设计。如果仔细看完，我相信你已经 get 到了 Thanos 的精髓，不过我们还没开始讲如何部署与实践，实际上在腾讯云容器服务的多个产品的内部监控已经在使用 Thanos 了，比如 &lt;a href=&#34;https://cloud.tencent.com/product/tke&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TKE&lt;/a&gt; (公有云 k8s)、&lt;a href=&#34;https://github.com/tkestack/tke&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TKEStack&lt;/a&gt; (私有云 k8s)、&lt;a href=&#34;https://console.cloud.tencent.com/tke2/ecluster&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EKS&lt;/a&gt; (Serverless k8s)。 下一篇我们将介绍 Thanos 的部署与最佳实践，敬请期待。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>打造云原生大型分布式监控系统(一): 大规模场景下 Prometheus 的优化手段</title>
      <link>/post/202003/build-cloud-native-large-scale-distributed-monitoring-system-1/</link>
      <pubDate>Thu, 26 Mar 2020 22:50:00 +0800</pubDate>
      <guid>/post/202003/build-cloud-native-large-scale-distributed-monitoring-system-1/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#概述&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#大规模场景下-prometheus-的痛点&#34;&gt;大规模场景下 Prometheus 的痛点&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#从服务维度拆分-prometheus&#34;&gt;从服务维度拆分 Prometheus&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#对超大规模的服务做分片&#34;&gt;对超大规模的服务做分片&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#拆分引入的新问题&#34;&gt;拆分引入的新问题&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#集中数据存储&#34;&gt;集中数据存储&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#prometheus-联邦&#34;&gt;Prometheus 联邦&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#prometheus-高可用&#34;&gt;Prometheus 高可用&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#总结&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;Prometheus 几乎已成为监控领域的事实标准，它自带高效的时序数据库存储，可以让单台 Prometheus 能够高效的处理大量的数据，还有友好并且强大的 PromQL 语法，可以用来灵活的查询各种监控数据以及配置告警规则，同时它的 pull 模型指标采集方式被广泛采纳，非常多的应用都实现了 Prometheus 的 metrics 接口以暴露自身各项数据指标让 Prometheus 去采集，很多没有适配的应用也会有第三方 exporter 帮它去适配 Prometheus，所以监控系统我们通常首选用 Prometheus，本系列文章也将基于 Prometheus 来打造云原生环境下的大型分布式监控系统。&lt;/p&gt;
&lt;h2 id=&#34;大规模场景下-prometheus-的痛点&#34;&gt;大规模场景下 Prometheus 的痛点&lt;/h2&gt;
&lt;p&gt;Prometheus 本身只支持单机部署，没有自带支持集群部署，也就不支持高可用以及水平扩容，在大规模场景下，最让人关心的问题是它的存储空间也受限于单机磁盘容量，磁盘容量决定了单个 Prometheus 所能存储的数据量，数据量大小又取决于被采集服务的指标数量、服务数量、采集速率以及数据过期时间。在数据量大的情况下，我们可能就需要做很多取舍，比如丢弃不重要的指标、降低采集速率、设置较短的数据过期时间(默认只保留15天的数据，看不到比较久远的监控数据)。&lt;/p&gt;
&lt;p&gt;这些痛点实际也是可以通过一些优化手段来改善的，下面我们来细讲一下。&lt;/p&gt;
&lt;h2 id=&#34;从服务维度拆分-prometheus&#34;&gt;从服务维度拆分 Prometheus&lt;/h2&gt;
&lt;p&gt;Prometheus 主张根据功能或服务维度进行拆分，即如果要采集的服务比较多，一个 Prometheus 实例就配置成仅采集和存储某一个或某一部分服务的指标，这样根据要采集的服务将 Prometheus 拆分成多个实例分别去采集，也能一定程度上达到水平扩容的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/prometheus-divide.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;通常这样的扩容方式已经能满足大部分场景的需求了，毕竟单机 Prometheus 就能采集和处理很多数据了，很少有 Prometheus 撑不住单个服务的场景。不过在超大规模集群下，有些单个服务的体量也很大，就需要进一步拆分了，我们下面来继续讲下如何再拆分。&lt;/p&gt;
&lt;h2 id=&#34;对超大规模的服务做分片&#34;&gt;对超大规模的服务做分片&lt;/h2&gt;
&lt;p&gt;想象一下，如果集群节点数量达到上千甚至几千的规模，对于一些节点级服务暴露的指标，比如 kubelet 内置的 cadvisor 暴露的容器相关的指标，又或者部署的 DeamonSet &lt;code&gt;node-exporter&lt;/code&gt; 暴露的节点相关的指标，在集群规模大的情况下，它们这种单个服务背后的指标数据体量就非常大；还有一些用户量超大的业务，单个服务的 pod 副本数就可能过千，这种服务背后的指标数据也非常大，当然这是最罕见的场景，对于绝大多数的人来说这种场景都只敢 YY 一下，实际很少有单个服务就达到这么大规模的业务。&lt;/p&gt;
&lt;p&gt;针对上面这些大规模场景，一个 Prometheus 实例可能连这单个服务的采集任务都扛不住。Prometheus 需要向这个服务所有后端实例发请求采集数据，由于后端实例数量规模太大，采集并发量就会很高，一方面对节点的带宽、CPU、磁盘 IO 都有一定的压力，另一方面 Prometheus 使用的磁盘空间有限，采集的数据量过大很容易就将磁盘塞满了，通常要做一些取舍才能将数据量控制在一定范围，但这种取舍也会降低数据完整和精确程度，不推荐这样做。&lt;/p&gt;
&lt;p&gt;那么如何优化呢？我们可以给这种大规模类型的服务做一下分片(Sharding)，将其拆分成多个 group，让一个 Prometheus 实例仅采集这个服务背后的某一个 group 的数据，这样就可以将这个大体量服务的监控数据拆分到多个 Prometheus 实例上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/prometheus-sharding.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如何将一个服务拆成多个 group 呢？下面介绍两种方案，以对 kubelet cadvisor 数据做分片为例。&lt;/p&gt;
&lt;p&gt;第一，我们可以不用 Kubernetes 的服务发现，自行实现一下 sharding 算法，比如针对节点级的服务，可以将某个节点 shard 到某个 group 里，然后再将其注册到 Prometheus 所支持的服务发现注册中心，推荐 consul，最后在 Prometheus 配置文件加上 &lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/configuration/configuration/#consul_sd_config&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;consul_sd_config&lt;/a&gt; 的配置，指定每个 Prometheus 实例要采集的 group。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - job_name: &#39;cadvisor-1&#39;
    consul_sd_configs:
      - server: 10.0.0.3:8500
        services:
          - cadvisor-1 # This is the 2nd slave
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在未来，你甚至可以直接利用 Kubernetes 的 &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/endpoint-slices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EndpointSlice&lt;/a&gt; 特性来做服务发现和分片处理，在超大规模服务场景下就可以不需要其它的服务发现和分片机制。不过暂时此特性还不够成熟，没有默认启用，不推荐用(当前 Kubernentes 最新版本为 1.18)。&lt;/p&gt;
&lt;p&gt;第二，用 Kubernetes 的 node 服务发现，再利用 Prometheus relabel 配置的 hashmod 来对 node 做分片，每个 Prometheus 实例仅抓其中一个分片中的数据:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - job_name: &#39;cadvisor-1&#39;
    metrics_path: /metrics/cadvisor
    scheme: https

    # 请求 kubelet metrics 接口也需要认证和授权，通常会用 webhook 方式让 apiserver 代理进行 RBAC 校验，所以还是用 ServiceAccount 的 token
    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token

    kubernetes_sd_configs:
    - role: node

    # 通常不校验 kubelet 的 server 证书，避免报 x509: certificate signed by unknown authority
    tls_config:
      insecure_skip_verify: true

    relabel_configs:
    - source_labels: [__address__]
      modulus:       4    # 将节点分片成 4 个 group
      target_label:  __tmp_hash
      action:        hashmod
    - source_labels: [__tmp_hash]
      regex:         ^1$  # 只抓第 2 个 group 中节点的数据(序号 0 为第 1 个 group)
      action:        keep
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;拆分引入的新问题&#34;&gt;拆分引入的新问题&lt;/h2&gt;
&lt;p&gt;前面我们通过不通层面对 Prometheus 进行了拆分部署，一方面使得 Prometheus 能够实现水平扩容，另一方面也加剧了监控数据落盘的分散程度，使用 Grafana 查询监控数据时我们也需要添加许多数据源，而且不同数据源之间的数据还不能聚合查询，监控页面也看不到全局的视图，造成查询混乱的局面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/prometheus-chaos.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;要解决这个问题，我们可以从下面的两方面入手，任选其中一种方案。&lt;/p&gt;
&lt;h2 id=&#34;集中数据存储&#34;&gt;集中数据存储&lt;/h2&gt;
&lt;p&gt;我们可以让 Prometheus 不负责存储，仅采集数据并通过 remote write 方式写入远程存储的 adapter，远程存储使用 OpenTSDB 或 InfluxDB 这些支持集群部署的时序数据库，Prometheus 配置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  remote_write:
  - url: http://10.0.0.2:8888/write
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后 Grafana 添加我们使用的时序数据库作为数据源来查询监控数据来展示，架构图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/prometheus-remotewirte.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这种方式相当于更换了存储引擎，由其它支持存储水平扩容的时序数据库来存储庞大的数据量，这样我们就可以将数据集中到一起。OpenTSDB 支持 HBase, BigTable 作为存储后端，InfluxDB 企业版支持集群部署和水平扩容(开源版不支持)。不过这样的话，我们就无法使用友好且强大的 PromQL 来查询监控数据了，必须使用我们存储数据的时序数据库所支持的语法来查询。&lt;/p&gt;
&lt;h2 id=&#34;prometheus-联邦&#34;&gt;Prometheus 联邦&lt;/h2&gt;
&lt;p&gt;除了上面更换存储引擎的方式，还可以将 Prometheus 进行联邦部署。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/prometheus-federation.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;简单来说，就是将多个 Prometheus 实例采集的数据再用另一个 Prometheus 采集汇总到一起，这样也意味着需要消耗更多的资源。通常我们只把需要聚合的数据或者需要在一个地方展示的数据用这种方式采集汇总到一起，比如 Kubernetes 节点数过多，cadvisor 的数据分散在多个 Prometheus 实例上，我们就可以用这种方式将 cadvisor 暴露的容器指标汇总起来，以便于在一个地方就能查询到集群中任意一个容器的监控数据或者某个服务背后所有容器的监控数据的聚合汇总以及配置告警；又或者多个服务有关联，比如通常应用只暴露了它应用相关的指标，但它的资源使用情况(比如 cpu 和 内存) 由 cadvisor 来感知和暴露，这两部分指标由不同的 Prometheus 实例所采集，这时我们也可以用这种方式将数据汇总，在一个地方展示和配置告警。&lt;/p&gt;
&lt;p&gt;更多说明和配置示例请参考官方文档: &lt;a href=&#34;https://prometheus.io/docs/prometheus/latest/federation/&#34;&gt;https://prometheus.io/docs/prometheus/latest/federation/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;prometheus-高可用&#34;&gt;Prometheus 高可用&lt;/h2&gt;
&lt;p&gt;虽然上面我们通过一些列操作将 Prometheus 进行了分布式改造，但并没有解决 Prometheus 本身的高可用问题，即如果其中一个实例挂了，数据的查询和完整性都将受到影响。&lt;/p&gt;
&lt;p&gt;我们可以将所有 Prometheus 实例都使用两个相同副本，分别挂载数据盘，它们都采集相同的服务，所以它们的数据是一致的，查询它们之中任意一个都可以，所以可以在它们前面再挂一层负载均衡，所有查询都经过这个负载均衡分流到其中一台 Prometheus，如果其中一台挂掉就从负载列表里踢掉不再转发。&lt;/p&gt;
&lt;p&gt;这里的负载均衡可以根据实际环境选择合适的方案，可以用 Nginx 或 HAProxy，在 Kubernetes 环境，通常使用 Kubernentes 的 Service，由 kube-proxy 生成的 iptables/ipvs 规则转发，如果使用 Istio，还可以用 VirtualService，由 envoy sidecar 去转发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/prometheus-ha.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这样就实现了 Prometheus 的高可用，简单起见，上面的图仅展示单个 Prometheus 的高可用，当你可以将其拓展，代入应用到上面其它的优化手段中，实现整体的高可用。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过本文一系列对 Prometheus 的优化手段，我们在一定程度上解决了单机 Prometheus 在大规模场景下的痛点，但操作和运维复杂度比较高，并且不能够很好的支持数据的长期存储(long term storage)。对于一些时间比较久远的监控数据，我们通常查看的频率很低，但也希望能够低成本的保留足够长的时间，数据如果全部落盘到磁盘成本是很高的，并且容量有限，即便利用水平扩容可以增加存储容量，但同时也增大了资源成本，不可能无限扩容，所以需要设置一个数据过期策略，也就会丢失时间比较久远的监控数据。&lt;/p&gt;
&lt;p&gt;对于这种不常用的冷数据，最理想的方式就是存到廉价的对象存储中，等需要查询的时候能够自动加载出来。Thanos 可以帮我们解决这些问题，它完全兼容 Prometheus API，提供统一查询聚合分布式部署的 Prometheus 数据的能力，同时也支持数据长期存储到各种对象存储(无限存储能力)以及降低采样率来加速大时间范围的数据查询。&lt;/p&gt;
&lt;p&gt;下一篇我们将会介绍 Thanos 的架构详解，敬请期待。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes 疑难杂症排查分享：神秘的溢出与丢包</title>
      <link>/post/202001/kubernetes-overflow-and-drop/</link>
      <pubDate>Sun, 12 Jan 2020 19:20:00 +0800</pubDate>
      <guid>/post/202001/kubernetes-overflow-and-drop/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#问题描述&#34;&gt;问题描述&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#猜测&#34;&gt;猜测&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#抓包&#34;&gt;抓包&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#syn-queue-与-accept-queue&#34;&gt;syn queue 与 accept queue&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#listen-与-accept&#34;&gt;listen 与 accept&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#linux-的-backlog&#34;&gt;Linux 的 backlog&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#队列溢出&#34;&gt;队列溢出&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#回到问题上来&#34;&gt;回到问题上来&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#somaxconn-的默认值很小&#34;&gt;somaxconn 的默认值很小&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#方式一-使用-k8s-sysctls-特性直接给-pod-指定内核参数&#34;&gt;方式一: 使用 k8s sysctls 特性直接给 pod 指定内核参数&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#方式二-使用-initcontainers-设置内核参数&#34;&gt;方式二: 使用 initContainers 设置内核参数&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#方式三-安装-tuning-cni-插件统一设置-sysctl&#34;&gt;方式三: 安装 tuning CNI 插件统一设置 sysctl&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#nginx-的-backlog&#34;&gt;nginx 的 backlog&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#参考资料&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;blockquote&gt;
&lt;p&gt;上一篇 &lt;a href=&#34;https://imroc.io/posts/kubernetes/kubernetes-no-route-to-host/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 疑难杂症排查分享: 诡异的 No route to host&lt;/a&gt; 不小心又爆火，这次继续带来干货，看之前请提前泡好茶，避免口干。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;有用户反馈大量图片加载不出来。&lt;/p&gt;
&lt;p&gt;图片下载走的 k8s ingress，这个 ingress 路径对应后端 service 是一个代理静态图片文件的 nginx deployment，这个 deployment 只有一个副本，静态文件存储在 nfs 上，nginx 通过挂载 nfs 来读取静态文件来提供图片下载服务，所以调用链是：client &amp;ndash;&amp;gt; k8s ingress &amp;ndash;&amp;gt; nginx &amp;ndash;&amp;gt; nfs。&lt;/p&gt;
&lt;h2 id=&#34;猜测&#34;&gt;猜测&lt;/h2&gt;
&lt;p&gt;猜测: ingress 图片下载路径对应的后端服务出问题了。&lt;/p&gt;
&lt;p&gt;验证：在 k8s 集群直接 curl nginx 的 pod ip，发现不通，果然是后端服务的问题！&lt;/p&gt;
&lt;h2 id=&#34;抓包&#34;&gt;抓包&lt;/h2&gt;
&lt;p&gt;继续抓包测试观察，登上 nginx pod 所在节点，进入容器的 netns 中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 拿到 pod 中 nginx 的容器 id
$ kubectl describe pod tcpbench-6484d4b457-847gl | grep -A10 &amp;quot;^Containers:&amp;quot; | grep -Eo &#39;docker://.*$&#39; | head -n 1 | sed &#39;s/docker:\/\/\(.*\)$/\1/&#39;
49b4135534dae77ce5151c6c7db4d528f05b69b0c6f8b9dd037ec4e7043c113e

# 通过容器 id 拿到 nginx 进程 pid
$ docker inspect -f {{.State.Pid}} 49b4135534dae77ce5151c6c7db4d528f05b69b0c6f8b9dd037ec4e7043c113e
3985

# 进入 nginx 进程所在的 netns
$ nsenter -n -t 3985

# 查看容器 netns 中的网卡信息，确认下
$ ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
3: eth0@if11: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default
    link/ether 56:04:c7:28:b0:3c brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.26.0.8/26 scope global eth0
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 tcpdump 指定端口 24568 抓容器 netns 中 eth0 网卡的包:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tcpdump -i eth0 -nnnn -ttt port 24568
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在其它节点准备使用 nc 指定源端口为 24568 向容器发包：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;nc -u 24568 172.16.1.21 80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;观察抓包结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;00:00:00.000000 IP 10.0.0.3.24568 &amp;gt; 172.16.1.21.80: Flags [S], seq 416500297, win 29200, options [mss 1424,sackOK,TS val 3000206334 ecr 0,nop,wscale 9], length 0
00:00:01.032218 IP 10.0.0.3.24568 &amp;gt; 172.16.1.21.80: Flags [S], seq 416500297, win 29200, options [mss 1424,sackOK,TS val 3000207366 ecr 0,nop,wscale 9], length 0
00:00:02.011962 IP 10.0.0.3.24568 &amp;gt; 172.16.1.21.80: Flags [S], seq 416500297, win 29200, options [mss 1424,sackOK,TS val 3000209378 ecr 0,nop,wscale 9], length 0
00:00:04.127943 IP 10.0.0.3.24568 &amp;gt; 172.16.1.21.80: Flags [S], seq 416500297, win 29200, options [mss 1424,sackOK,TS val 3000213506 ecr 0,nop,wscale 9], length 0
00:00:08.192056 IP 10.0.0.3.24568 &amp;gt; 172.16.1.21.80: Flags [S], seq 416500297, win 29200, options [mss 1424,sackOK,TS val 3000221698 ecr 0,nop,wscale 9], length 0
00:00:16.127983 IP 10.0.0.3.24568 &amp;gt; 172.16.1.21.80: Flags [S], seq 416500297, win 29200, options [mss 1424,sackOK,TS val 3000237826 ecr 0,nop,wscale 9], length 0
00:00:33.791988 IP 10.0.0.3.24568 &amp;gt; 172.16.1.21.80: Flags [S], seq 416500297, win 29200, options [mss 1424,sackOK,TS val 3000271618 ecr 0,nop,wscale 9], length 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SYN 包到容器内网卡了，但容器没回 ACK，像是报文到达容器内的网卡后就被丢了。看样子跟防火墙应该也没什么关系，也检查了容器 netns 内的 iptables 规则，是空的，没问题。&lt;/p&gt;
&lt;p&gt;排除是 iptables 规则问题，在容器 netns 中使用 &lt;code&gt;netstat -s&lt;/code&gt; 检查下是否有丢包统计:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ netstat -s | grep -E &#39;overflow|drop&#39;
    12178939 times the listen queue of a socket overflowed
    12247395 SYNs to LISTEN sockets dropped
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然有丢包，为了理解这里的丢包统计，我深入研究了一下，下面插播一些相关知识。&lt;/p&gt;
&lt;h2 id=&#34;syn-queue-与-accept-queue&#34;&gt;syn queue 与 accept queue&lt;/h2&gt;
&lt;p&gt;Linux 进程监听端口时，内核会给它对应的 socket 分配两个队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;syn queue: 半连接队列。server 收到 SYN 后，连接会先进入 &lt;code&gt;SYN_RCVD&lt;/code&gt; 状态，并放入 syn queue，此队列的包对应还没有完全建立好的连接（TCP 三次握手还没完成）。&lt;/li&gt;
&lt;li&gt;accept queue: 全连接队列。当 TCP 三次握手完成之后，连接会进入 &lt;code&gt;ESTABELISHED&lt;/code&gt; 状态并从 syn queue 移到 accept queue，等待被进程调用 &lt;code&gt;accept()&lt;/code&gt; 系统调用 &amp;ldquo;拿走&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：这两个队列的连接都还没有真正被应用层接收到，当进程调用 &lt;code&gt;accept()&lt;/code&gt; 后，连接才会被应用层处理，具体到我们这个问题的场景就是 nginx 处理 HTTP 请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了更好理解，可以看下这张 TCP 连接建立过程的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/backlog.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;listen-与-accept&#34;&gt;listen 与 accept&lt;/h2&gt;
&lt;p&gt;不管使用什么语言和框架，在写 server 端应用时，它们的底层在监听端口时最终都会调用 &lt;code&gt;listen()&lt;/code&gt; 系统调用，处理新请求时都会先调用 &lt;code&gt;accept()&lt;/code&gt; 系统调用来获取新的连接，然后再处理请求，只是有各自不同的封装而已，以 go 语言为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 调用 listen 监听端口
l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:80&amp;quot;)
if err != nil {
	panic(err)
}
for {
	// 不断调用 accept 获取新连接，如果 accept queue 为空就一直阻塞
	conn, err := l.Accept()
	if err != nil {
		log.Println(&amp;quot;accept error:&amp;quot;, err)
		continue
    }
	// 每来一个新连接意味着一个新请求，启动协程处理请求
	go handle(conn)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;linux-的-backlog&#34;&gt;Linux 的 backlog&lt;/h2&gt;
&lt;p&gt;内核既然给监听端口的 socket 分配了 syn queue 与 accept queue 两个队列，那它们有大小限制吗？可以无限往里面塞数据吗？当然不行！ 资源是有限的，尤其是在内核态，所以需要限制一下这两个队列的大小。那么它们的大小是如何确定的呢？我们先来看下 listen 这个系统调用:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;int listen(int sockfd, int backlog)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，能够传入一个整数类型的 &lt;code&gt;backlog&lt;/code&gt; 参数，我们再通过 &lt;code&gt;man listen&lt;/code&gt; 看下解释：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;The behavior of the backlog argument on TCP sockets changed with Linux 2.2.  Now it specifies the queue length for completely established sockets waiting to  be  accepted,  instead  of  the  number  of  incomplete  connection requests.   The  maximum  length  of  the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog.  When syncookies are enabled there is no logical maximum length and this setting is ignored.  See tcp(7) for more information. &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;If the backlog argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128.  In kernels before 2.4.25, this limit  was  a  hard  coded value, SOMAXCONN, with the value 128.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;继续深挖了一下源码，结合这里的解释提炼一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;listen 的 backlog 参数同时指定了 socket 的 syn queue 与 accept queue 大小。&lt;/li&gt;
&lt;li&gt;accept queue 最大不能超过 &lt;code&gt;net.core.somaxconn&lt;/code&gt; 的值，即:
&lt;pre&gt;&lt;code&gt;max accept queue size = min(backlog, net.core.somaxconn)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;如果启用了 syncookies (net.ipv4.tcp_syncookies=1)，当 syn queue 满了，server 还是可以继续接收 &lt;code&gt;SYN&lt;/code&gt; 包并回复 &lt;code&gt;SYN+ACK&lt;/code&gt; 给 client，只是不会存入 syn queue 了。因为会利用一套巧妙的 syncookies 算法机制生成隐藏信息写入响应的 &lt;code&gt;SYN+ACK&lt;/code&gt; 包中，等 client 回 &lt;code&gt;ACK&lt;/code&gt; 时，server 再利用 syncookies 算法校验报文，校验通过后三次握手就顺利完成了。所以如果启用了 syncookies，syn queue 的逻辑大小是没有限制的，&lt;/li&gt;
&lt;li&gt;syncookies 通常都是启用了的，所以一般不用担心 syn queue 满了导致丢包。syncookies 是为了防止 SYN Flood 攻击 (一种常见的 DDoS 方式)，攻击原理就是 client 不断发 SYN 包但不回最后的 ACK，填满 server 的 syn queue 从而无法建立新连接，导致 server 拒绝服务。&lt;/li&gt;
&lt;li&gt;如果 syncookies 没有启用，syn queue 的大小就有限制，除了跟 accept queue 一样受 &lt;code&gt;net.core.somaxconn&lt;/code&gt; 大小限制之外，还会受到 &lt;code&gt;net.ipv4.tcp_max_syn_backlog&lt;/code&gt; 的限制，即:
&lt;pre&gt;&lt;code&gt;max syn queue size = min(backlog, net.core.somaxconn, net.ipv4.tcp_max_syn_backlog)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.3 及其之前版本的内核，syn queue 的大小计算方式跟现在新版内核这里还不一样，详细请参考 commit &lt;a href=&#34;https://github.com/torvalds/linux/commit/ef547f2ac16bd9d77a780a0e7c70857e69e8f23f#diff-56ecfd3cd70d57cde321f395f0d8d743L43&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ef547f2ac16b&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;队列溢出&#34;&gt;队列溢出&lt;/h2&gt;
&lt;p&gt;毫无疑问，在队列大小有限制的情况下，如果队列满了，再有新连接过来肯定就有问题。&lt;/p&gt;
&lt;p&gt;翻下 linux 源码，看下处理 SYN 包的部分，在 &lt;code&gt;net/ipv4/tcp_input.c&lt;/code&gt; 的 &lt;code&gt;tcp_conn_request&lt;/code&gt; 函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if ((net-&amp;gt;ipv4.sysctl_tcp_syncookies == 2 ||
     inet_csk_reqsk_queue_is_full(sk)) &amp;amp;&amp;amp; !isn) {
	want_cookie = tcp_syn_flood_action(sk, rsk_ops-&amp;gt;slab_name);
	if (!want_cookie)
		goto drop;
}

if (sk_acceptq_is_full(sk)) {
	NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
	goto drop;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;goto drop&lt;/code&gt; 最终会走到 &lt;code&gt;tcp_listendrop&lt;/code&gt; 函数，实际上就是将 &lt;code&gt;ListenDrops&lt;/code&gt; 计数器 +1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline void tcp_listendrop(const struct sock *sk)
{
	atomic_inc(&amp;amp;((struct sock *)sk)-&amp;gt;sk_drops);
	__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大致可以看出来，对于 SYN 包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 syn queue 满了并且没有开启 syncookies 就丢包，并将 &lt;code&gt;ListenDrops&lt;/code&gt; 计数器 +1。&lt;/li&gt;
&lt;li&gt;如果 accept queue 满了也会丢包，并将 &lt;code&gt;ListenOverflows&lt;/code&gt; 和 &lt;code&gt;ListenDrops&lt;/code&gt; 计数器 +1。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而我们前面排查问题通过 &lt;code&gt;netstat -s&lt;/code&gt; 看到的丢包统计，其实就是对应的 &lt;code&gt;ListenOverflows&lt;/code&gt; 和 &lt;code&gt;ListenDrops&lt;/code&gt; 这两个计数器。&lt;/p&gt;
&lt;p&gt;除了用 &lt;code&gt;netstat -s&lt;/code&gt;，还可以使用 &lt;code&gt;nstat -az&lt;/code&gt; 直接看系统内各个计数器的值:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ nstat -az | grep -E &#39;TcpExtListenOverflows|TcpExtListenDrops&#39;
TcpExtListenOverflows           12178939              0.0
TcpExtListenDrops               12247395              0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，对于低版本内核，当 accept queue 满了，并不会完全丢弃 SYN 包，而是对 SYN 限速。把内核源码切到 3.10 版本，看 &lt;code&gt;net/ipv4/tcp_ipv4.c&lt;/code&gt; 中 &lt;code&gt;tcp_v4_conn_request&lt;/code&gt; 函数:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* Accept backlog is full. If we have already queued enough
 * of warm entries in syn queue, drop request. It is better than
 * clogging syn queue with openreqs with exponentially increasing
 * timeout.
 */
if (sk_acceptq_is_full(sk) &amp;amp;&amp;amp; inet_csk_reqsk_queue_young(sk) &amp;gt; 1) {
        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
        goto drop;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;inet_csk_reqsk_queue_young(sk) &amp;gt; 1&lt;/code&gt; 的条件实际就是用于限速，仿佛在对 client 说: 哥们，你慢点！我的 accept queue 都满了，即便咱们握手成功，连接也可能放不进去呀。&lt;/p&gt;
&lt;h2 id=&#34;回到问题上来&#34;&gt;回到问题上来&lt;/h2&gt;
&lt;p&gt;总结之前观察到两个现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器内抓包发现收到 client 的 SYN，但 nginx 没回包。&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;netstat -s&lt;/code&gt; 发现有溢出和丢包的统计 (&lt;code&gt;ListenOverflows&lt;/code&gt; 与 &lt;code&gt;ListenDrops&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据之前的分析，我们可以推测是 syn queue 或 accept queue 满了。&lt;/p&gt;
&lt;p&gt;先检查下 syncookies 配置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /proc/sys/net/ipv4/tcp_syncookies
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确认启用了 &lt;code&gt;syncookies&lt;/code&gt;，所以 syn queue 大小没有限制，不会因为 syn queue 满而丢包，并且即便没开启 &lt;code&gt;syncookies&lt;/code&gt;，syn queue 有大小限制，队列满了也不会使 &lt;code&gt;ListenOverflows&lt;/code&gt; 计数器 +1。&lt;/p&gt;
&lt;p&gt;从计数器结果来看，&lt;code&gt;ListenOverflows&lt;/code&gt; 和 &lt;code&gt;ListenDrops&lt;/code&gt; 的值差别不大，所以推测很有可能是 accept queue 满了，因为当 accept queue 满了会丢 SYN 包，并且同时将 &lt;code&gt;ListenOverflows&lt;/code&gt; 与 &lt;code&gt;ListenDrops&lt;/code&gt; 计数器分别 +1。&lt;/p&gt;
&lt;p&gt;如何验证 accept queue 满了呢？可以在容器的 netns 中执行 &lt;code&gt;ss -lnt&lt;/code&gt; 看下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ss -lnt
State      Recv-Q Send-Q Local Address:Port                Peer Address:Port
LISTEN     129    128                *:80                             *:*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这条命令我们可以看到当前 netns 中监听 tcp 80 端口的 socket，&lt;code&gt;Send-Q&lt;/code&gt; 为 128，&lt;code&gt;Recv-Q&lt;/code&gt; 为 129。&lt;/p&gt;
&lt;p&gt;什么意思呢？通过调研得知：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;LISTEN&lt;/code&gt; 状态，&lt;code&gt;Send-Q&lt;/code&gt; 表示 accept queue 的最大限制大小，&lt;code&gt;Recv-Q&lt;/code&gt; 表示其实际大小。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;ESTABELISHED&lt;/code&gt; 状态，&lt;code&gt;Send-Q&lt;/code&gt; 和 &lt;code&gt;Recv-Q&lt;/code&gt; 分别表示发送和接收数据包的 buffer。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，看这里输出结果可以得知 accept queue 满了，当 &lt;code&gt;Recv-Q&lt;/code&gt; 的值比 &lt;code&gt;Send-Q&lt;/code&gt; 大 1 时表明 accept queue 溢出了，如果再收到 SYN 包就会丢弃掉。&lt;/p&gt;
&lt;p&gt;导致 accept queue 满的原因一般都是因为进程调用 &lt;code&gt;accept()&lt;/code&gt; 太慢了，导致大量连接不能被及时 &amp;ldquo;拿走&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;那么什么情况下进程调用 &lt;code&gt;accept()&lt;/code&gt; 会很慢呢？猜测可能是进程连接负载高，处理不过来。&lt;/p&gt;
&lt;p&gt;而负载高不仅可能是 CPU 繁忙导致，还可能是 IO 慢导致，当文件 IO 慢时就会有很多 IO WAIT，在 IO WAIT 时虽然 CPU 不怎么干活，但也会占据 CPU 时间片，影响 CPU 干其它活。&lt;/p&gt;
&lt;p&gt;最终进一步定位发现是 nginx pod 挂载的 nfs 服务对应的 nfs server 负载较高，导致 IO 延时较大，从而使 nginx 调用 &lt;code&gt;accept()&lt;/code&gt; 变慢，accept queue 溢出，使得大量代理静态图片文件的请求被丢弃，也就导致很多图片加载不出来。&lt;/p&gt;
&lt;p&gt;虽然根因不是 k8s 导致的问题，但也从中挖出一些在高并发场景下值得优化的点，请继续往下看。&lt;/p&gt;
&lt;h2 id=&#34;somaxconn-的默认值很小&#34;&gt;somaxconn 的默认值很小&lt;/h2&gt;
&lt;p&gt;我们再看下之前 &lt;code&gt;ss -lnt&lt;/code&gt; 的输出:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ss -lnt
State      Recv-Q Send-Q Local Address:Port                Peer Address:Port
LISTEN     129    128                *:80                             *:*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仔细一看，&lt;code&gt;Send-Q&lt;/code&gt; 表示 accept queue 最大的大小，才 128 ？也太小了吧！&lt;/p&gt;
&lt;p&gt;根据前面的介绍我们知道，accept queue 的最大大小会受 &lt;code&gt;net.core.somaxconn&lt;/code&gt; 内核参数的限制，我们看下 pod 所在节点上这个内核参数的大小:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /proc/sys/net/core/somaxconn
32768
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是 32768，挺大的，为什么这里 accept queue 最大大小就只有 128 了呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net.core.somaxconn&lt;/code&gt; 这个内核参数是 namespace 隔离了的，我们在容器 netns 中再确认了下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /proc/sys/net/core/somaxconn
128
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么只有 128？看下 stackoverflow &lt;a href=&#34;https://stackoverflow.com/questions/26177059/refresh-net-core-somaxcomm-or-any-sysctl-property-for-docker-containers/26197875#26197875&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这里&lt;/a&gt; 的讨论:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;The &amp;quot;net/core&amp;quot; subsys is registered per network namespace. And the initial value for somaxconn is set to 128.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原来新建的 netns 中 somaxconn 默认就为 128，在 &lt;code&gt;include/linux/socket.h&lt;/code&gt; 中可以看到这个常量的定义:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* Maximum queue length specifiable by listen.  */
#define SOMAXCONN	128
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很多人在使用 k8s 时都没太在意这个参数，为什么大家平常在较高并发下也没发现有问题呢？&lt;/p&gt;
&lt;p&gt;因为通常进程 &lt;code&gt;accept()&lt;/code&gt; 都是很快的，所以一般 accept queue 基本都没什么积压的数据，也就不会溢出导致丢包了。&lt;/p&gt;
&lt;p&gt;对于并发量很高的应用，还是建议将 somaxconn 调高。虽然可以进入容器 netns 后使用 &lt;code&gt;sysctl -w net.core.somaxconn=1024&lt;/code&gt; 或 &lt;code&gt;echo 1024 &amp;gt; /proc/sys/net/core/somaxconn&lt;/code&gt; 临时调整，但调整的意义不大，因为容器内的进程一般在启动的时候才会调用 &lt;code&gt;listen()&lt;/code&gt;，然后 accept queue 的大小就被决定了，并且不再改变。&lt;/p&gt;
&lt;p&gt;下面介绍几种调整方式:&lt;/p&gt;
&lt;h3 id=&#34;方式一-使用-k8s-sysctls-特性直接给-pod-指定内核参数&#34;&gt;方式一: 使用 k8s sysctls 特性直接给 pod 指定内核参数&lt;/h3&gt;
&lt;p&gt;示例 yaml:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: sysctl-example
spec:
  securityContext:
    sysctls:
    - name: net.core.somaxconn
      value: &amp;quot;8096&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有些参数是 &lt;code&gt;unsafe&lt;/code&gt; 类型的，不同环境不一样，我的环境里是可以直接设置 pod 的 &lt;code&gt;net.core.somaxconn&lt;/code&gt; 这个 sysctl 的。如果你的环境不行，请参考官方文档 &lt;a href=&#34;https://kubernetes-io-vnext-staging.netlify.com/docs/tasks/administer-cluster/sysctl-cluster/#enabling-unsafe-sysctls&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Using sysctls in a Kubernetes Cluster&lt;/a&gt; 启用 &lt;code&gt;unsafe&lt;/code&gt; 类型的 sysctl。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：此特性在 k8s v1.12 beta，默认开启。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;方式二-使用-initcontainers-设置内核参数&#34;&gt;方式二: 使用 initContainers 设置内核参数&lt;/h3&gt;
&lt;p&gt;示例 yaml:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: sysctl-example-init
spec:
  initContainers:
  - image: busybox
    command:
    - sh
    - -c
    - echo 1024 &amp;gt; /proc/sys/net/core/somaxconn
    imagePullPolicy: Always
    name: setsysctl
    securityContext:
      privileged: true
  Containers:
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注: init container 需要 privileged 权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;方式三-安装-tuning-cni-插件统一设置-sysctl&#34;&gt;方式三: 安装 tuning CNI 插件统一设置 sysctl&lt;/h3&gt;
&lt;p&gt;tuning plugin 地址: &lt;a href=&#34;https://github.com/containernetworking/plugins/tree/master/plugins/meta/tuning&#34;&gt;https://github.com/containernetworking/plugins/tree/master/plugins/meta/tuning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CNI 配置示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;mytuning&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;tuning&amp;quot;,
  &amp;quot;sysctl&amp;quot;: {
          &amp;quot;net.core.somaxconn&amp;quot;: &amp;quot;1024&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nginx-的-backlog&#34;&gt;nginx 的 backlog&lt;/h2&gt;
&lt;p&gt;我们使用方式一尝试给 nginx pod 的 somaxconn 调高到 8096 后观察:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ss -lnt
State      Recv-Q Send-Q Local Address:Port                Peer Address:Port
LISTEN     512    511                *:80                             *:*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;WTF? 还是溢出了，而且调高了 somaxconn 之后虽然 accept queue 的最大大小 (&lt;code&gt;Send-Q&lt;/code&gt;) 变大了，但跟 8096 还差很远呀！&lt;/p&gt;
&lt;p&gt;在经过一番研究，发现 nginx 在 &lt;code&gt;listen()&lt;/code&gt; 时并没有读取 somaxconn 作为 backlog 默认值传入，它有自己的默认值，也支持在配置里改。通过 &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_core_module.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ngx_http_core_module&lt;/a&gt; 的官方文档我们可以看到它在 linux 下的默认值就是 511:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;backlog=number
   sets the backlog parameter in the listen() call that limits the maximum length for the queue of pending connections. By default, backlog is set to -1 on FreeBSD, DragonFly BSD, and macOS, and to 511 on other platforms.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;listen  80  default  backlog=1024;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，在容器中使用 nginx 来支撑高并发的业务时，记得要同时调整下 &lt;code&gt;net.core.somaxconn&lt;/code&gt; 内核参数和 &lt;code&gt;nginx.conf&lt;/code&gt; 中的 backlog 配置。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Using sysctls in a Kubernetes Cluster: &lt;a href=&#34;https://kubernetes-io-vnext-staging.netlify.com/docs/tasks/administer-cluster/sysctl-cluster/&#34;&gt;https://kubernetes-io-vnext-staging.netlify.com/docs/tasks/administer-cluster/sysctl-cluster/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SYN packet handling in the wild: &lt;a href=&#34;https://blog.cloudflare.com/syn-packet-handling-in-the-wild/&#34;&gt;https://blog.cloudflare.com/syn-packet-handling-in-the-wild/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes 疑难杂症排查分享: 诡异的 No route to host</title>
      <link>/post/201912/kubernetes-no-route-to-host/</link>
      <pubDate>Sun, 15 Dec 2019 12:03:00 +0800</pubDate>
      <guid>/post/201912/kubernetes-no-route-to-host/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#问题反馈&#34;&gt;问题反馈&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#分析&#34;&gt;分析&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#问题没有解决&#34;&gt;问题没有解决&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#深入分析&#34;&gt;深入分析&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#总结&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;p&gt;之前发过一篇干货满满的爆火文章 &lt;a href=&#34;https://imroc.io/posts/kubernetes/troubleshooting-with-kubernetes-network/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kubernetes 网络疑难杂症排查分享&lt;/a&gt;，包含多个疑难杂症的排查案例分享，信息量巨大。这次我又带来了续集，只讲一个案例，但信息量也不小，Are you ready ?&lt;/p&gt;
&lt;h2 id=&#34;问题反馈&#34;&gt;问题反馈&lt;/h2&gt;
&lt;p&gt;有用户反馈 Deployment 滚动更新的时候，业务日志偶尔会报 &amp;ldquo;No route to host&amp;rdquo; 的错误。&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;之前没遇到滚动更新会报 &amp;ldquo;No route to host&amp;rdquo; 的问题，我们先看下滚动更新导致连接异常有哪些常见的报错:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Connection reset by peer&lt;/code&gt;: 连接被重置。通常是连接建立过，但 server 端发现 client 发的包不对劲就返回 RST，应用层就报错连接被重置。比如在 server 滚动更新过程中，client 给 server 发的请求还没完全结束，或者本身是一个类似 grpc 的多路复用长连接，当 server 对应的旧 Pod 删除(没有做优雅结束，停止时没有关闭连接)，新 Pod 很快创建启动并且刚好有跟之前旧 Pod 一样的 IP，这时 kube-proxy 也没感知到这个 IP 其实已经被删除然后又被重建了，针对这个 IP 的规则就不会更新，旧的连接依然发往这个 IP，但旧 Pod 已经不在了，后面继续发包时依然转发给这个 Pod IP，最终会被转发到这个有相同 IP 的新 Pod 上，而新 Pod 收到此包时检查报文发现不对劲，就返回 RST 给 client 告知将连接重置。针对这种情况，建议应用自身处理好优雅结束：Pod 进入 Terminating 状态后会发送 &lt;code&gt;SIGTERM&lt;/code&gt; 信号给业务进程，业务进程的代码需处理这个信号，在进程退出前关闭所有连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Connection refused&lt;/code&gt;: 连接被拒绝。通常是连接还没建立，client 正在发 SYN 包请求建立连接，但到了 server 之后发现端口没监听，内核就返回 RST 包，然后应用层就报错连接被拒绝。比如在 server 滚动更新过程中，旧的 Pod 中的进程很快就停止了(网卡还未完全销毁)，但 client 所在节点的 iptables/ipvs 规则还没更新，包就可能会被转发到了这个停止的 Pod (由于 k8s 的 controller 模式，从 Pod 删除到 service 的 endpoint 更新，再到 kube-proxy watch 到更新并更新 节点上的 iptables/ipvs 规则，这个过程是异步的，中间存在一点时间差，所以有可能存在 Pod 中的进程已经没有监听，但 iptables/ipvs 规则还没更新的情况)。针对这种情况，建议给容器加一个 preStop，在真正销毁 Pod 之前等待一段时间，留时间给 kube-proxy 更新转发规则，更新完之后就不会再有新连接往这个旧 Pod 转发了，preStop 示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;lifecycle:
  preStop:
    exec:
      command:
      - /bin/bash
      - -c
      - sleep 30
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，还可能是新的 Pod 启动比较慢，虽然状态已经 Ready，但实际上可能端口还没监听，新的请求被转发到这个还没完全启动的 Pod 就会报错连接被拒绝。针对这种情况，建议给容器加就绪检查 (readinessProbe)，让容器真正启动完之后才将其状态置为 Ready，然后 kube-proxy 才会更新转发规则，这样就能保证新的请求只被转发到完全启动的 Pod，readinessProbe 示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;readinessProbe:
  httpGet:
    path: /healthz
    port: 80
    httpHeaders:
    - name: X-Custom-Header
      value: Awesome
  initialDelaySeconds: 15
  timeoutSeconds: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Connection timed out&lt;/code&gt;: 连接超时。通常是连接还没建立，client 发 SYN 请求建立连接一直等到超时时间都没有收到 ACK，然后就报错连接超时。这个可能场景跟前面 &lt;code&gt;Connection refused&lt;/code&gt; 可能的场景类似，不同点在于端口有监听，但进程无法正常响应了: 转发规则还没更新，旧 Pod 的进程正在停止过程中，虽然端口有监听，但已经不响应了；或者转发规则更新了，新 Pod 端口也监听了，但还没有真正就绪，还没有能力处理新请求。针对这些情况的建议跟前面一样：加 preStop 和 readinessProbe。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们来继续分析下滚动更新时发生 &lt;code&gt;No route to host&lt;/code&gt; 的可能情况。&lt;/p&gt;
&lt;p&gt;这个报错很明显，IP 无法路由，通常是将报文发到了一个已经彻底销毁的 Pod (网卡已经不在)。不可能发到一个网卡还没创建好的 Pod，因为即便不加存活检查，也是要等到 Pod 网络初始化完后才可能 Ready，然后 kube-proxy 才会更新转发规则。&lt;/p&gt;
&lt;p&gt;什么情况下会转发到一个已经彻底销毁的 Pod？ 借鉴前面几种滚动更新的报错分析，我们推测应该是 Pod 很快销毁了但转发规则还没更新，从而新的请求被转发了这个已经销毁的 Pod，最终报文到达这个 Pod 所在 PodCIDR 的 Node 上时，Node 发现本机已经没有这个 IP 的容器，然后 Node 就返回 ICMP 包告知 client 这个 IP 不可达，client 收到 ICMP 后，应用层就会报错 &amp;ldquo;No route to host&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;所以根据我们的分析，关键点在于 Pod 销毁太快，转发规则还没来得及更新，导致后来的请求被转发到已销毁的 Pod。针对这种情况，我们可以给容器加一个 preStop，留时间给 kube-proxy 更新转发规则来解决，参考 《Kubernetes实践指南》中的部分章节: &lt;a href=&#34;https://k8s.imroc.io/best-practice/high-availability-deployment-of-applications#smooth-update-using-prestophook-and-readinessprobe&#34;&gt;https://k8s.imroc.io/best-practice/high-availability-deployment-of-applications#smooth-update-using-prestophook-and-readinessprobe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;问题没有解决&#34;&gt;问题没有解决&lt;/h2&gt;
&lt;p&gt;我们自己没有复现用户的 &amp;ldquo;No route to host&amp;rdquo; 的问题，可能是复现条件比较苛刻，最后将我们上面理论上的分析结论作为解决方案给到了用户。&lt;/p&gt;
&lt;p&gt;但用户尝试加了 preStop 之后，问题依然存在，服务滚动更新时偶尔还是会出现 &amp;ldquo;No route to host&amp;rdquo;。&lt;/p&gt;
&lt;h2 id=&#34;深入分析&#34;&gt;深入分析&lt;/h2&gt;
&lt;p&gt;为了弄清楚根本原因，我们请求用户协助搭建了一个可以复现问题的测试环境，最终这个问题在测试环境中可以稳定复现。&lt;/p&gt;
&lt;p&gt;仔细观察，实际是部署两个服务：ServiceA 和 ServiceB。使用 ab 压测工具去压测 ServiceA （短连接），然后 ServiceA 会通过 RPC 调用 ServiceB (短连接)，滚动更新的是 ServiceB，报错发生在 ServiceA 调用 ServiceB 这条链路。&lt;/p&gt;
&lt;p&gt;在 ServiceB 滚动更新期间，新的 Pod Ready 了之后会被添加到 IPVS 规则的 RS 列表，但旧的 Pod 不会立即被踢掉，而是将新的 Pod 权重置为1，旧的置为 0，通过在 client 所在节点查看 IPVS 规则可以看出来:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@VM-0-3-ubuntu:~# ipvsadm -ln -t 172.16.255.241:80
Prot LocalAddress:Port Scheduler Flags
  -&amp;gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  172.16.255.241:80 rr
  -&amp;gt; 172.16.8.106:80              Masq    0      5          14048
  -&amp;gt; 172.16.8.107:80              Masq    1      2          243
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么不立即踢掉旧的 Pod 呢？因为要支持优雅结束，让存量的连接处理完，等存量连接全部结束了再踢掉它(ActiveConn+InactiveConn=0)，这个逻辑可以通过这里的代码确认：https://github.com/kubernetes/kubernetes/blob/v1.17.0/pkg/proxy/ipvs/graceful_termination.go#L170&lt;/p&gt;
&lt;p&gt;然后再通过 &lt;code&gt;ipvsadm -lnc | grep 172.16.8.106&lt;/code&gt; 发现旧 Pod 上的连接大多是 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态，这个也容易理解：因为 ServiceA 作为 client 发起短连接请求调用 ServiceB，调用完成就会关闭连接，TCP 三次挥手后进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态，等待 2*MSL (2 分钟) 的时长再清理连接。&lt;/p&gt;
&lt;p&gt;经过上面的分析，看起来都是符合预期的，那为什么还会出现 &amp;ldquo;No route to host&amp;rdquo; 呢？难道权重被置为 0 之后还有新连接往这个旧 Pod 转发？我们来抓包看下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@VM-0-3-ubuntu:~# tcpdump -i eth0 host 172.16.8.106 -n -tttt
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
2019-12-13 11:49:47.319093 IP 10.0.0.3.36708 &amp;gt; 172.16.8.106.80: Flags [S], seq 3988339656, win 29200, options [mss 1460,sackOK,TS val 3751111666 ecr 0,nop,wscale 9], length 0
2019-12-13 11:49:47.319133 IP 10.0.0.3.36706 &amp;gt; 172.16.8.106.80: Flags [S], seq 109196945, win 29200, options [mss 1460,sackOK,TS val 3751111666 ecr 0,nop,wscale 9], length 0
2019-12-13 11:49:47.319144 IP 10.0.0.3.36704 &amp;gt; 172.16.8.106.80: Flags [S], seq 1838682063, win 29200, options [mss 1460,sackOK,TS val 3751111666 ecr 0,nop,wscale 9], length 0
2019-12-13 11:49:47.319153 IP 10.0.0.3.36702 &amp;gt; 172.16.8.106.80: Flags [S], seq 1591982963, win 29200, options [mss 1460,sackOK,TS val 3751111666 ecr 0,nop,wscale 9], length 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;果然是！即使权重为 0，仍然会尝试发 SYN 包跟这个旧 Pod 建立连接，但永远无法收到 ACK，因为旧 Pod 已经销毁了。为什么会这样呢？难道是 IPVS 内核模块的调度算法有问题？尝试去看了下 linux 内核源码，并没有发现哪个调度策略的实现函数会将新连接调度到权重为 0 的 rs 上。&lt;/p&gt;
&lt;p&gt;这就奇怪了，可能不是调度算法的问题？继续尝试看更多的代码，主要是 &lt;code&gt;net/netfilter/ipvs/ip_vs_core.c&lt;/code&gt; 中的 &lt;code&gt;ip_vs_in&lt;/code&gt; 函数，也就是 IPVS 模块处理报文的主要入口，发现它会先在本地连接转发表看这个包是否已经有对应的连接了（匹配五元组），如果有就说明它不是新连接也就不会调度，直接发给这个连接对应的之前已经调度过的 rs (也不会判断权重)；如果没匹配到说明这个包是新的连接，就会走到调度这里 (rr, wrr 等调度策略)，这个逻辑看起来也没问题。&lt;/p&gt;
&lt;p&gt;那为什么会转发到权重为 0 的 rs ？难道是匹配连接这里出问题了？新的连接匹配到了旧的连接？我开始做实验验证这个猜想，修改一下这里的逻辑：检查匹配到的连接对应的 rs 如果权重为 0，则重新调度。然后重新编译和加载 IPVS 内核模块，再重新压测一下，发现问题解决了！没有报 &amp;ldquo;No route to host&amp;rdquo; 了。&lt;/p&gt;
&lt;p&gt;虽然通过改内核源码解决了，但我知道这不是一个好的解决方案，它会导致 IPVS 不支持连接的优雅结束，因为不再转发包给权重为 0 的 rs，存量的连接就会立即中断。&lt;/p&gt;
&lt;p&gt;继续陷入深思&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;这个实验只是证明了猜想：新连接匹配到了旧连接。那为什么会这样呢？难道新连接报文的五元组跟旧连接的相同了？&lt;/p&gt;
&lt;p&gt;经过一番思考，发现这个是有可能的。因为 ServiceA 作为 client 请求 ServiceB，不同请求的源 IP 始终是相同的，关键点在于源端口是否可能相同。由于 ServiceA 向 ServiceB 发起大量短连接，ServiceA 所在节点就会有大量 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态的连接，需要等 2 分钟 (2*MSL) 才会清理，而由于连接量太大，每次发起的连接都会占用一个源端口，当源端口不够用了，就会重用 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态连接的源端口，这个时候当报文进入 IPVS 模块，检测到它的五元组跟本地连接转发表中的某个连接一致(&lt;code&gt;TIME_WAIT&lt;/code&gt; 状态)，就以为它是一个存量连接，然后直接将报文转发给这个连接之前对应的 rs 上，然而这个 rs 对应的 Pod 早已销毁，所以抓包看到的现象是将 SYN 发给了旧 Pod，并且无法收到 ACK，伴随着返回 ICMP 告知这个 IP 不可达，也被应用解释为 &amp;ldquo;No route to host&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;后来无意间又发现一个还在 open 状态的 issue，虽然还没提到 &amp;ldquo;No route to host&amp;rdquo; 关键字，但讨论的跟我们这个其实是同一个问题。我也参与了讨论，有兴趣的同学可以看下：https://github.com/kubernetes/kubernetes/issues/81775&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这个问题通常发生的场景就是类似于我们测试环境这种：ServiceA 对外提供服务，当外部发起请求，ServiceA 会通过 rpc 或 http 调用 ServiceB，如果外部请求量变大，ServiceA 调用 ServiceB 的量也会跟着变大，大到一定程度，ServiceA 所在节点源端口不够用，复用 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态连接的源端口，导致五元组跟 IPVS 里连接转发表中的 &lt;code&gt;TIME_WAIT&lt;/code&gt; 连接相同，IPVS 就认为这是一个存量连接的报文，就不判断权重直接转发给之前的 rs，导致转发到已销毁的 Pod，从而发生 &amp;ldquo;No route to host&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;如何规避？集群规模小可以使用 iptables 模式，如果需要使用 ipvs 模式，可以增加 ServiceA 的副本，并且配置反亲和性 (podAntiAffinity)，让 ServiceA 的 Pod 部署到不同节点，分摊流量，避免流量集中到某一个节点，导致调用 ServiceB 时源端口复用。&lt;/p&gt;
&lt;p&gt;如何彻底解决？暂时还没有一个完美的方案。&lt;/p&gt;
&lt;p&gt;Issue 85517 讨论让 kube-proxy 支持自定义配置几种连接状态的超时时间，但这对 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态无效。&lt;/p&gt;
&lt;p&gt;Issue 81308 讨论 IVPS 的优雅结束是否不考虑不活跃的连接 (包括 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态的连接)，也就是只考虑活跃连接，当活跃连接数为 0 之后立即踢掉 rs。这个确实可以更快的踢掉 rs，但无法让优雅结束做到那么优雅了，并且有人测试了，即便是不考虑不活跃连接，当请求量很大，还是不能很快踢掉 rs，因为源端口复用还是会导致不断有新的连接占用旧的连接，在较新的内核版本，&lt;code&gt;SYN_RECV&lt;/code&gt; 状态也被视为活跃连接，所以活跃连接数还是不会很快降到 0。&lt;/p&gt;
&lt;p&gt;这个问题的终极解决方案该走向何方，我们拭目以待，感兴趣的同学可以持续关注 issue 81775 并参与讨论。想学习更多 K8S 知识，可以关注本人的开源书《Kubernetes实践指南》: &lt;a href=&#34;https://k8s.imroc.io&#34;&gt;https://k8s.imroc.io&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>k8s v1.17 新特性预告: 拓扑感知服务路由</title>
      <link>/post/201911/</link>
      <pubDate>Tue, 26 Nov 2019 16:49:00 +0800</pubDate>
      <guid>/post/201911/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#名词解释&#34;&gt;名词解释&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#背景&#34;&gt;背景&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#k8s-亲和性&#34;&gt;k8s 亲和性&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何实现&#34;&gt;如何实现&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#前提条件&#34;&gt;前提条件&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何启用此特性&#34;&gt;如何启用此特性&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#如何使用&#34;&gt;如何使用&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#背后小故事&#34;&gt;背后小故事&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#结尾&#34;&gt;结尾&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#参考资料&#34;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;p&gt;今天给大家介绍下我参与开发的一个 k8s v1.17 新特性: 拓扑感知服务路由。&lt;/p&gt;
&lt;h2 id=&#34;名词解释&#34;&gt;名词解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;拓扑域: 表示在集群中的某一类 &amp;ldquo;地方&amp;rdquo;，比如某节点、某机架、某可用区或某地域等，这些都可以作为某种拓扑域。&lt;/li&gt;
&lt;li&gt;endpoint: k8s 某个服务的某个 ip+port，通常是 pod 的 ip+port。&lt;/li&gt;
&lt;li&gt;service: k8s 的 service 资源(服务)，关联一组 endpoint ，访问 service 会被转发到关联的某个 endpoint 上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;拓扑感知服务路由，此特性最初由杜军大佬提出并设计。为什么要设计此特性呢？想象一下，k8s 集群节点分布在不同的地方，service 对应的 endpoints 分布在不同节点，传统转发策略会对所有 endpoint 做负载均衡，通常会等概率转发，当访问 service 时，流量就可能被分散打到这些不同的地方。虽然 service 转发做了负载均衡，但如果 endpoint 距离比较远，流量转发过去网络时延就相对比较高，会影响网络性能，在某些情况下甚至还可能会付出额外的流量费用。要是如能实现 service 就近转发 endpoint，是不是就可以实现降低网络时延，提升网络性能了呢？是的！这也正是该特性所提出的目的和意义。&lt;/p&gt;
&lt;h2 id=&#34;k8s-亲和性&#34;&gt;k8s 亲和性&lt;/h2&gt;
&lt;p&gt;service 的就近转发实际就是一种网络的亲和性，倾向于转发到离自己比较近的 endpoint。在此特性之前，已经在调度和存储方面有一些亲和性的设计与实现:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点亲和性 (Node Affinity): 让 Pod 被调度到符合一些期望条件的 Node 上，比如限制调度到某一可用区，或者要求节点支持 GPU，这算是调度亲和，调度结果取决于节点属性。&lt;/li&gt;
&lt;li&gt;Pod 亲和性与反亲和性 (Pod Affinity/AntiAffinity): 让一组 Pod 调度到同一拓扑域的节点上，或者打散到不同拓扑域的节点， 这也算是调度亲和，调度结果取决于其它 Pod。&lt;/li&gt;
&lt;li&gt;数据卷拓扑感知调度 (Volume Topology-aware Scheduling): 让 Pod 只被调度到符合其绑定的存储所在拓扑域的节点上，这算是调度与存储的亲和，调度结果取决于存储的拓扑域。&lt;/li&gt;
&lt;li&gt;本地数据卷 (Local Persistent Volume): 让 Pod 使用本地数据卷，比如高性能 SSD，在某些需要高 IOPS 低时延的场景很有用，它还会保证 Pod 始终被调度到同一节点，数据就不会不丢失，这也算是调度与存储的亲和，调度结果取决于存储所在节点。&lt;/li&gt;
&lt;li&gt;数据卷拓扑感知动态创建 (Topology-Aware Volume Dynamic Provisioning): 先调度 Pod，再根据 Pod 所在节点的拓扑域来创建存储，这算是存储与调度的亲和，存储的创建取决于调度的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 k8s 目前在网络方面还没有亲和性能力，拓扑感知服务路由这个新特性恰好可以补齐这个的空缺，此特性使得 service 可以实现就近转发而不是所有 endpoint 等概率转发。&lt;/p&gt;
&lt;h2 id=&#34;如何实现&#34;&gt;如何实现&lt;/h2&gt;
&lt;p&gt;我们知道，service 转发主要是 node 上的 kube-proxy 进程通过 watch apiserver 获取 service 对应的 endpoint，再写入 iptables 或 ipvs 规则来实现的; 对于 headless service，主要是通过 kube-dns 或 coredns 动态解析到不同 endpoint ip 来实现的。实现 service 就近转发的关键点就在于如何将流量转发到跟当前节点在同一拓扑域的 endpoint 上，也就是会进行一次 endpoint 筛选，选出一部分符合当前节点拓扑域的 endpoint 进行转发。&lt;/p&gt;
&lt;p&gt;那么如何判断 endpoint 跟当前节点是否在同一拓扑域里呢？只要能获取到 endpoint 的拓扑信息，用它跟当前节点拓扑对比下就可以知道了。那又如何获取 endpoint 的拓扑信息呢？答案是通过 endpoint 所在节点的 label，我们可以使用 node label 来描述拓扑域。&lt;/p&gt;
&lt;p&gt;通常在节点初始化的时候，controller-manager 就会为节点打上许多 label，比如 &lt;code&gt;kubernetes.io/hostname&lt;/code&gt; 表示节点的 hostname 来区分节点；另外，在云厂商提供的 k8s 服务，或者使用 cloud-controller-manager 的自建集群，通常还会给节点打上 &lt;code&gt;failure-domain.beta.kubernetes.io/zone&lt;/code&gt; 和 &lt;code&gt;failure-domain.beta.kubernetes.io/region&lt;/code&gt; 以区分节点所在可用区和所在地域，但自 v1.17 开始将会改名成 &lt;code&gt;topology.kubernetes.io/zone&lt;/code&gt; 和 &lt;code&gt;topology.kubernetes.io/region&lt;/code&gt;，参见 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/81431&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PR #81431&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如何根据 endpoint 查到它所在节点的这些 label 呢？答案是通过 &lt;code&gt;Endpoint Slice&lt;/code&gt;，该特性在 v1.16 发布了 alpha，在 v1.17 将会进入 beta，它相当于 Endpoint API 增强版，通过将 endpoint 做数据分片来解决大规模 endpoint 的性能问题，并且可以携带更多的信息，包括 endpoint 所在节点的拓扑信息，拓扑感知服务路由特性会通过 &lt;code&gt;Endpoint Slice&lt;/code&gt; 获取这些拓扑信息实现 endpoint 筛选 (过滤出在同一拓扑域的 endpoint)，然后再转换为 iptables 或 ipvs 规则写入节点以实现拓扑感知的路由转发。&lt;/p&gt;
&lt;p&gt;细心的你可能已经发现，之前每个节点上转发 service 的 iptables/ipvs 规则基本是一样的，但启用了拓扑感知服务路由特性之后，每个节点上的转发规则就可能不一样了，因为不同节点的拓扑信息不一样，导致过滤出的 endpoint 就不一样，也正是因为这样，service 转发变得不再等概率，灵活的就近转发才得以实现。&lt;/p&gt;
&lt;p&gt;当前还不支持 headless service 的拓扑路由，计划在 beta 阶段支持。由于 headless service 不是通过 kube-proxy 生成转发规则，而是通过 dns 动态解析实现的，所以需要改 kube-dns/coredns 来支持这个特性。&lt;/p&gt;
&lt;h2 id=&#34;前提条件&#34;&gt;前提条件&lt;/h2&gt;
&lt;p&gt;启用当前 alpha 实现的拓扑感知服务路由特性需要满足以下前提条件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集群版本在 v1.17 及其以上。&lt;/li&gt;
&lt;li&gt;Kube-proxy 以 iptables 或 IPVS 模式运行 (alpha 阶段暂时只实现了这两种模式)。&lt;/li&gt;
&lt;li&gt;启用了 &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/endpoint-slices/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Endpoint Slices&lt;/a&gt; (此特性虽然在 v1.17 进入 beta，但没有默认开启)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何启用此特性&#34;&gt;如何启用此特性&lt;/h2&gt;
&lt;p&gt;给所有 k8s 组件打开 &lt;code&gt;ServiceTopology&lt;/code&gt; 和 &lt;code&gt;EndpointSlice&lt;/code&gt; 这两个 feature:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--feature-gates=&amp;quot;ServiceTopology=true,EndpointSlice=true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;如何使用&#34;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;在 Service spec 里加上 &lt;code&gt;topologyKeys&lt;/code&gt; 字段，表示该 Service 优先顺序选用的拓扑域列表，对应节点标签的 key；当访问此 Service 时，会找是否有 endpoint 有对应 topology key 的拓扑信息并且 value 跟当前节点也一样，如果是，那就选定此 topology key 作为当前转发的拓扑域，并且筛选出其余所有在这个拓扑域的 endpoint 来进行转发；如果没有找到任何 endpoint 在当前 topology key 对应拓扑域，就会尝试第二个 topology key，依此类推；如果遍历完所有 topology key 也没有匹配到 endpoint 就会拒绝转发，就像此 service 没有后端 endpoint 一样。&lt;/p&gt;
&lt;p&gt;有一个特殊的 topology key &amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;quot;，它可以匹配所有 endpoint，如果 &lt;code&gt;topologyKeys&lt;/code&gt; 包含了 &lt;code&gt;*&lt;/code&gt;，它必须在列表末尾，通常是在没有匹配到合适的拓扑域来实现就近转发时，就打消就近转发的念头，可以转发到任意 endpoint 上。&lt;/p&gt;
&lt;p&gt;当前 topology key 支持以下可能的值（未来会增加更多）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kubernetes.io/hostname&lt;/code&gt;: 节点的 hostname，通常将它放列表中第一个，表示如果本机有 endpoint 就直接转发到本机的 endpoint。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;topology.kubernetes.io/zone&lt;/code&gt;: 节点所在的可用区，通常将它放在 &lt;code&gt;kubernetes.io/hostname&lt;/code&gt; 后面，表示如果本机没有对应 endpoint，就转发到当前可用区其它节点上的 endpoint（部分云厂商跨可用区通信会收取额外的流量费用）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;topology.kubernetes.io/region&lt;/code&gt;: 表示节点所在的地域，表示转发到当前地域的 endpoint，这个用的应该会比较少，因为通常集群所有节点都只会在同一个地域，如果节点跨地域了，节点之间通信延时将会很高。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;: 忽略拓扑域，匹配所有 endpoint，相当于一个保底策略，避免丢包，只能放在列表末尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，还有以下约束:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;topologyKeys&lt;/code&gt; 与 &lt;code&gt;externalTrafficPolicy=Local&lt;/code&gt; 不兼容，是互斥的，如果 &lt;code&gt;externalTrafficPolicy&lt;/code&gt; 为 &lt;code&gt;Local&lt;/code&gt;，就不能定义 &lt;code&gt;topologyKeys&lt;/code&gt;，反之亦然。&lt;/li&gt;
&lt;li&gt;topology key 必须是合法的 label 格式，并且最多定义 16 个 key。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里给出一个简单的 Service 示例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  name: nginx
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: nginx
  topologyKeys: [&amp;quot;kubernetes.io/hostname&amp;quot;, &amp;quot;topology.kubernetes.io/zone&amp;quot;, &amp;quot;*&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解释: 当访问 nginx 服务时，首先看本机是否有这个服务的 endpoint，如果有就直接本机路由过去；如果没有，就看是否有 endpoint 位于当前节点所在可用区，如果有，就转发过去，如果还是没有，就转发给任意 endpoint。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/service-topology.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图就是其中一次转发的例子：Pod 访问 nginx 这个 service 时，发现本机没有 endpoint，就找当前可用区的，找到了就转发过去，也就不会考虑转发给另一可用区的 endpoint。&lt;/p&gt;
&lt;h2 id=&#34;背后小故事&#34;&gt;背后小故事&lt;/h2&gt;
&lt;p&gt;此特性的 KEP Proposal 最终被认可（合并）时的设计与当前最终的代码实现已经有一些差别，实现方案历经一变再变，但同时也推动了其它特性的发展，我来讲下这其中的故事。&lt;/p&gt;
&lt;p&gt;一开始设计是在 alpha 时，让 kube-proxy 直接暴力 watch node，每个节点都有一份全局的 node 的缓存，通过 endpoint 的 &lt;code&gt;nodeName&lt;/code&gt; 字段找到对应的 node 缓存，再查 node 包含的 label 就可以知道该 endpoint 的拓扑域了，但在集群节点数量多的情况下，kube-proxy 将会消耗大量资源，不过优点是实现上很简单，可以作为 alpha 阶段的实现，beta 时再从 watch node 切换到 watch 一个新设计的 PodLocator API，作为拓扑信息存储的中介，避免 watch 庞大的 node。&lt;/p&gt;
&lt;p&gt;实际上一开始我也是按照 watch node 的方式，花了九牛二虎之力终于实现了这个特性，后来 v1.15 时 k8s 又支持了 metadata-only watch，参见 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/71548&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PR 71548&lt;/a&gt;，利用此特性可以仅仅 watch node 的 metadata，而不用 watch 整个 node，可以极大减小传输和缓存的数据量，然后我就将实现切成了 watch node metadata; 即便如此，metadata 还是会更新比较频繁，主要是 &lt;code&gt;resourceVersion&lt;/code&gt; 会经常变 (kubelet 经常上报 node 状态)，所以虽然 watch node metadata 比 watch node 要好，但也还是可能会造成大量不必要的网络流量，但作为 alpha 实现是可以接受的。&lt;/p&gt;
&lt;p&gt;可惜在 v1.16 code freeze 之前没能将此特性合进去，只因有一点小细节还没讨论清楚。 实际在实现 watch node 方案期间，Endpoint Slice 特性就提出来了，在这个特性讨论的阶段，我们就想到了可以利用它来携带拓扑信息，以便让拓扑感知服务路由这个特性后续可以直接利用 Endpoint Slice 来获取拓扑信息，也就可以替代之前设计的 PodLocator API，但由于它还处于很早期阶段，并且代码还未合并进去，所以 alpha 阶段先不考虑 watch Endpint Slice。后来，Endpoint Slice 特性在 v1.16 发布了 alpha。&lt;/p&gt;
&lt;p&gt;由于 v1.16 没能将拓扑感知服务路由特性合进去，在 v1.17 周期开始后，有更多时间来讨论小细节，并且 Endpoint Slice 代码已经合并，我就干脆直接又将实现从 watch node metadata 切成了 watch Endpint Slice，在 alpha 阶段就做了打算在 beta 阶段做的事情，终于，此特性实现代码最终合进了主干。&lt;/p&gt;
&lt;h2 id=&#34;结尾&#34;&gt;结尾&lt;/h2&gt;
&lt;p&gt;拓扑感知服务路由可以实现 service 就近转发，减少网络延时，进一步提升 k8s 的网络性能，此特性将于 k8s v1.17 发布 alpha，时间是 12 月上旬，让我们一起期待吧！k8s 网络是块难啃的硬骨头，感兴趣的同学可以看下杜军的新书 &lt;a href=&#34;https://item.jd.com/12724298.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Kubernetes 网络权威指南》&lt;/a&gt;，整理巩固一下 k8s 的网络知识。&lt;/p&gt;
&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;KEP: EndpintSlice - &lt;a href=&#34;https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/20190603-EndpointSlice-API.md&#34;&gt;https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/20190603-EndpointSlice-API.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Proposal: Volume Topology-aware Scheduling - &lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/volume-topology-scheduling.md&#34;&gt;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/volume-topology-scheduling.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PR: Service Topology implementation for Kubernetes - &lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/72046&#34;&gt;https://github.com/kubernetes/kubernetes/pull/72046&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Proposal: Inter-pod topological affinity and anti-affinity - &lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/podaffinity.md&#34;&gt;https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/podaffinity.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Topology-Aware Volume Provisioning in Kubernetes - &lt;a href=&#34;https://kubernetes.io/blog/2018/10/11/topology-aware-volume-provisioning-in-kubernetes/&#34;&gt;https://kubernetes.io/blog/2018/10/11/topology-aware-volume-provisioning-in-kubernetes/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kubernetes 1.14: Local Persistent Volumes GA - &lt;a href=&#34;https://kubernetes.io/blog/2019/04/04/kubernetes-1.14-local-persistent-volumes-ga/&#34;&gt;https://kubernetes.io/blog/2019/04/04/kubernetes-1.14-local-persistent-volumes-ga/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;KubeCon 演讲: 面向 k8s 的拓扑感知服务路由即将推出! - &lt;a href=&#34;https://v.qq.com/x/page/t0893nn9zqa.html&#34;&gt;https://v.qq.com/x/page/t0893nn9zqa.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;拓扑感知服务路由官方文档(等v1.17发布后才能看到) - &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service-topology/&#34;&gt;https://kubernetes.io/docs/concepts/services-networking/service-topology/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;KEP: Topology-aware service routing - &lt;a href=&#34;https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/20181024-service-topology.md&#34;&gt;https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/20181024-service-topology.md&lt;/a&gt; (此文档后续会更新，因为实现跟设计已经不一样了)&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes 网络疑难杂症排查分享</title>
      <link>/post/201908/troubleshooting-with-kubernetes-network/</link>
      <pubDate>Mon, 12 Aug 2019 16:59:00 +0800</pubDate>
      <guid>/post/201908/troubleshooting-with-kubernetes-network/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#跨-vpc-访问-nodeport-经常超时&#34;&gt;跨 VPC 访问 NodePort 经常超时&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#lb-压测-cps-低&#34;&gt;LB 压测 CPS 低&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#dns-解析偶尔-5s-延时&#34;&gt;DNS 解析偶尔 5S 延时&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#pod-访问另一个集群的-apiserver-有延时&#34;&gt;Pod 访问另一个集群的 apiserver 有延时&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#dns-解析异常&#34;&gt;DNS 解析异常&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#pod-偶尔存活检查失败&#34;&gt;Pod 偶尔存活检查失败&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#访问-externaltrafficpolicy-为-local-的-service-对应-lb-有时超时&#34;&gt;访问 externalTrafficPolicy 为 Local 的 Service 对应 LB 有时超时&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#结语&#34;&gt;结语&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;p&gt;大家好，我是 roc，来自腾讯云容器服务(TKE)团队，经常帮助用户解决各种 K8S 的疑难杂症，积累了比较丰富的经验，本文分享几个比较复杂的网络方面的问题排查和解决思路，深入分析并展开相关知识，信息量巨大，相关经验不足的同学可能需要细细品味才能消化，我建议收藏本文反复研读，当完全看懂后我相信你的功底会更加扎实，解决问题的能力会大大提升。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文发现的问题是在使用 TKE 时遇到的，不同厂商的网络环境可能不一样，文中会对不同的问题的网络环境进行说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/dengguangshi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;跨-vpc-访问-nodeport-经常超时&#34;&gt;跨 VPC 访问 NodePort 经常超时&lt;/h2&gt;
&lt;p&gt;现象: 从 VPC a 访问 VPC b 的 TKE 集群的某个节点的 NodePort，有时候正常，有时候会卡住直到超时。&lt;/p&gt;
&lt;p&gt;原因怎么查？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/emoji_analysis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当然是先抓包看看啦，抓 server 端 NodePort 的包，发现异常时 server 能收到 SYN，但没响应 ACK:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/no_ack.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;反复执行 &lt;code&gt;netstat -s | grep LISTEN&lt;/code&gt; 发现 SYN 被丢弃数量不断增加:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/drop_syn.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个VPC之间使用对等连接打通的，CVM 之间通信应该就跟在一个内网一样可以互通。&lt;/li&gt;
&lt;li&gt;为什么同一 VPC 下访问没问题，跨 VPC 有问题? 两者访问的区别是什么?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/man_need_think.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;再仔细看下 client 所在环境，发现 client 是 VPC a 的 TKE 集群节点，捋一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;client 在 VPC a 的 TKE 集群的节点&lt;/li&gt;
&lt;li&gt;server 在 VPC b 的 TKE 集群的节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 TKE 集群中有个叫 &lt;code&gt;ip-masq-agent&lt;/code&gt; 的 daemonset，它会给 node 写 iptables 规则，默认 SNAT 目的 IP 是 VPC 之外的报文，所以 client 访问 server 会做 SNAT，也就是这里跨 VPC 相比同 VPC 访问 NodePort 多了一次 SNAT，如果是因为多了一次 SNAT 导致的这个问题，直觉告诉我这个应该跟内核参数有关，因为是 server 收到包没回包，所以应该是 server 所在 node 的内核参数问题，对比这个 node 和 普通 TKE node 的默认内核参数，发现这个 node &lt;code&gt;net.ipv4.tcp_tw_recycle = 1&lt;/code&gt;，这个参数默认是关闭的，跟用户沟通后发现这个内核参数确实在做压测的时候调整过。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/chijing2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;解释一下，TCP 主动关闭连接的一方在发送最后一个 ACK 会进入 &lt;code&gt;TIME_AWAIT&lt;/code&gt; 状态，再等待 2 个 MSL 时间后才会关闭(因为如果 server 没收到 client 第四次挥手确认报文，server 会重发第三次挥手 FIN 报文，所以 client 需要停留 2 MSL的时长来处理可能会重复收到的报文段；同时等待 2 MSL 也可以让由于网络不通畅产生的滞留报文失效，避免新建立的连接收到之前旧连接的报文)，了解更详细的过程请参考 TCP 四次挥手。&lt;/p&gt;
&lt;p&gt;参数 &lt;code&gt;tcp_tw_recycle&lt;/code&gt; 用于快速回收 &lt;code&gt;TIME_AWAIT&lt;/code&gt; 连接，通常在增加连接并发能力的场景会开启，比如发起大量短连接，快速回收可避免  &lt;code&gt;tw_buckets&lt;/code&gt; 资源耗尽导致无法建立新连接 (&lt;code&gt;time wait bucket table overflow&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;查得 &lt;code&gt;tcp_tw_recycle&lt;/code&gt; 有个坑，在 RFC1323 有段描述:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;An additional mechanism could be added to the TCP, a per-host cache of the last timestamp received from any connection. This value could then be used in the PAWS mechanism to reject old duplicate segments from earlier incarnations of the connection, if the timestamp clock can be guaranteed to have ticked at least once since the old connection was open. This would require that the TIME-WAIT delay plus the RTT together must be at least one tick of the sender’s timestamp clock. Such an extension is not part of the proposal of this RFC.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大概意思是说 TCP 有一种行为，可以缓存每个连接最新的时间戳，后续请求中如果时间戳小于缓存的时间戳，即视为无效，相应的数据包会被丢弃。&lt;/p&gt;
&lt;p&gt;Linux 是否启用这种行为取决于 &lt;code&gt;tcp_timestamps&lt;/code&gt; 和 &lt;code&gt;tcp_tw_recycle&lt;/code&gt;，因为 &lt;code&gt;tcp_timestamps&lt;/code&gt; 缺省开启，所以当 &lt;code&gt;tcp_tw_recycle&lt;/code&gt; 被开启后，实际上这种行为就被激活了，当客户端或服务端以 &lt;code&gt;NAT&lt;/code&gt; 方式构建的时候就可能出现问题。&lt;/p&gt;
&lt;p&gt;当多个客户端通过 NAT 方式联网并与服务端交互时，服务端看到的是同一个 IP，也就是说对服务端而言这些客户端实际上等同于一个，可惜由于这些客户端的时间戳可能存在差异，于是乎从服务端的视角看，便可能出现时间戳错乱的现象，进而直接导致时间戳小的数据包被丢弃。如果发生了此类问题，具体的表现通常是是客户端明明发送的 SYN，但服务端就是不响应 ACK。&lt;/p&gt;
&lt;p&gt;回到我们的问题上，client 所在节点上可能也会有其它 pod 访问到 server 所在节点，而它们都被 SNAT 成了 client 所在节点的 NODE IP，但时间戳存在差异，server 就会看到时间戳错乱，因为开启了 &lt;code&gt;tcp_tw_recycle&lt;/code&gt; 和 &lt;code&gt;tcp_timestamps&lt;/code&gt; 激活了上述行为，就丢掉了比缓存时间戳小的报文，导致部分 SYN 被丢弃，这也解释了为什么之前我们抓包发现异常时 server 收到了 SYN，但没有响应 ACK，进而说明为什么 client 的请求部分会卡住直到超时。&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;tcp_tw_recycle&lt;/code&gt; 坑太多，在内核 4.12 之后已移除: &lt;a href=&#34;https://github.com/torvalds/linux/commit/4396e46187ca5070219b81773c4e65088dac50cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;remove tcp_tw_recycle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/laugh1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;lb-压测-cps-低&#34;&gt;LB 压测 CPS 低&lt;/h2&gt;
&lt;p&gt;现象: LoadBalancer 类型的 Service，直接压测 NodePort CPS 比较高，但如果压测 LB CPS 就很低。&lt;/p&gt;
&lt;p&gt;环境说明: 用户使用的黑石TKE，不是公有云TKE，黑石的机器是物理机，LB的实现也跟公有云不一样，但 LoadBalancer 类型的 Service 的实现同样也是 LB 绑定各节点的 NodePort，报文发到 LB 后转到节点的 NodePort， 然后再路由到对应 pod，而测试在公有云 TKE 环境下没有这个问题。&lt;/p&gt;
&lt;p&gt;client 抓包: 大量SYN重传。&lt;/p&gt;
&lt;p&gt;server 抓包: 抓 NodePort 的包，发现当 client SYN 重传时 server 能收到 SYN 包但没有响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/emoji_analysis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;又是 SYN 收到但没响应，难道又是开启 &lt;code&gt;tcp_tw_recycle&lt;/code&gt; 导致的？检查节点的内核参数发现并没有开启，除了这个原因，还会有什么情况能导致被丢弃？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conntrack -S&lt;/code&gt; 看到 &lt;code&gt;insert_failed&lt;/code&gt; 数量在不断增加，也就是 conntrack 在插入很多新连接的时候失败了，为什么会插入失败？什么情况下会插入失败？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/analysis_forever.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;挖内核源码: netfilter conntrack 模块为每个连接创建 conntrack 表项时，表项的创建和最终插入之间还有一段逻辑，没有加锁，是一种乐观锁的过程。conntrack 表项并发刚创建时五元组不冲突的话可以创建成功，但中间经过 NAT 转换之后五元组就可能变成相同，第一个可以插入成功，后面的就会插入失败，因为已经有相同的表项存在。比如一个 SYN 已经做了 NAT 但是还没到最终插入的时候，另一个 SYN 也在做 NAT，因为之前那个 SYN 还没插入，这个 SYN 做 NAT 的时候就认为这个五元组没有被占用，那么它 NAT 之后的五元组就可能跟那个还没插入的包相同。&lt;/p&gt;
&lt;p&gt;在我们这个问题里实际就是 netfilter 做 SNAT 时源端口选举冲突了，黑石 LB 会做 SNAT，SNAT 时使用了 16 个不同 IP 做源，但是短时间内源 Port 却是集中一致的，并发两个 SYN a 和SYN b，被 LB SNAT 后源 IP 不同但源 Port 很可能相同，这里就假设两个报文被 LB SNAT 之后它们源 IP 不同源 Port 相同，报文同时到了节点的 NodePort 会再次做 SNAT 再转发到对应的 Pod，当报文到了 NodePort 时，这时它们五元组不冲突，netfilter 为它们分别创建了 conntrack 表项，SYN a 被节点 SNAT 时默认行为是 从 port_range 范围的当前源 Port 作为起始位置开始循环遍历，选举出没有被占用的作为源 Port，因为这两个 SYN 源 Port 相同，所以它们源 Port 选举的起始位置相同，当 SYN a 选出源 Port 但还没将 conntrack 表项插入时，netfilter 认为这个 Port 没被占用就很可能给 SYN b 也选了相同的源 Port，这时他们五元组就相同了，当 SYN a 的 conntrack 表项插入后再插入 SYN b 的 conntrack 表项时，发现已经有相同的记录就将 SYN b 的 conntrack 表项丢弃了。&lt;/p&gt;
&lt;p&gt;解决方法探索: 不使用源端口选举，在 iptables 的 MASQUERADE 规则如果加 &lt;code&gt;--random-fully&lt;/code&gt; 这个 flag 可以让端口选举完全随机，基本上能避免绝大多数的冲突，但也无法完全杜绝。最终决定开发 LB 直接绑 Pod IP，不基于 NodePort，从而避免 netfilter 的 SNAT 源端口冲突问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/emoji_jizhi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;dns-解析偶尔-5s-延时&#34;&gt;DNS 解析偶尔 5S 延时&lt;/h2&gt;
&lt;p&gt;网上一搜，是已知问题，仔细分析，实际跟之前黑石 TKE 压测 LB CPS 低的根因是同一个，都是因为 netfilter conntrack 模块的设计问题，只不过之前发生在 SNAT，这个发生在 DNAT，这里用我的语言来总结下原因:&lt;/p&gt;
&lt;p&gt;DNS client (glibc 或 musl libc) 会并发请求 A 和 AAAA 记录，跟 DNS Server 通信自然会先 connect (建立fd)，后面请求报文使用这个 fd 来发送，由于 UDP 是无状态协议， connect 时并不会发包，也就不会创建 conntrack 表项, 而并发请求的 A 和 AAAA 记录默认使用同一个 fd 发包，send 时各自发的包它们源 Port 相同(因为用的同一个socket发送)，当并发发包时，两个包都还没有被插入 conntrack 表项，所以 netfilter 会为它们分别创建 conntrack 表项，而集群内请求 kube-dns 或 coredns 都是访问的CLUSTER-IP，报文最终会被 DNAT 成一个 endpoint 的 POD IP，当两个包恰好又被 DNAT 成同一个 POD IP时，它们的五元组就相同了，在最终插入的时候后面那个包就会被丢掉，如果 dns 的 pod 副本只有一个实例的情况就很容易发生(始终被DNAT成同一个POD IP)，现象就是 dns 请求超时，client 默认策略是等待 5s 自动重试，如果重试成功，我们看到的现象就是 dns 请求有 5s 的延时。&lt;/p&gt;
&lt;p&gt;参考 weave works 工程师总结的文章: &lt;a href=&#34;https://www.weave.works/blog/racy-conntrack-and-dns-lookup-timeouts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Racy conntrack and DNS lookup timeouts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解决方案一: 使用 TCP 发送 DNS 请求&lt;/p&gt;
&lt;p&gt;如果使用 TCP 发 DNS 请求，connect 时就会发包建立连接并插入 conntrack 表项，而后并发的 A 和 AAAA 记录的请求在 send 时都使用 connect 建立好的这个 fd，由于 connect 时 conntrack 表项已经建立，所以 send 时不会再建立，也就不存在并发创建 conntrack 表项，避免了冲突。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolv.conf&lt;/code&gt; 可以加 &lt;code&gt;options use-vc&lt;/code&gt; 强制 glibc 使用 TCP 协议发送 DNS query。下面是这个 &lt;code&gt;man resolv.conf&lt;/code&gt;中关于这个选项的说明:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;use-vc (since glibc 2.14)
                     Sets RES_USEVC in _res.options.  This option forces the
                     use of TCP for DNS resolutions.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决方案二: 避免相同五元组 DNS 请求的并发&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resolv.conf&lt;/code&gt; 还有另外两个相关的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;single-request-reopen (since glibc 2.9): A 和 AAAA 请求使用不同的 socket 来发送，这样它们的源 Port 就不同，五元组也就不同，避免了使用同一个 conntrack 表项。&lt;/li&gt;
&lt;li&gt;single-request (since glibc 2.10): A 和 AAAA 请求改成串行，没有并发，从而也避免了冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;man resolv.conf&lt;/code&gt; 中解释如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;single-request-reopen (since glibc 2.9)
                     Sets RES_SNGLKUPREOP in _res.options.  The resolver
                     uses the same socket for the A and AAAA requests.  Some
                     hardware mistakenly sends back only one reply.  When
                     that happens the client system will sit and wait for
                     the second reply.  Turning this option on changes this
                     behavior so that if two requests from the same port are
                     not handled correctly it will close the socket and open
                     a new one before sending the second request.

single-request (since glibc 2.10)
                     Sets RES_SNGLKUP in _res.options.  By default, glibc
                     performs IPv4 and IPv6 lookups in parallel since
                     version 2.9.  Some appliance DNS servers cannot handle
                     these queries properly and make the requests time out.
                     This option disables the behavior and makes glibc
                     perform the IPv6 and IPv4 requests sequentially (at the
                     cost of some slowdown of the resolving process).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要给容器的 &lt;code&gt;resolv.conf&lt;/code&gt; 加上 options 参数，最方便的是直接在 Pod Spec 里面的 dnsConfig 加 (k8s v1.9 及以上才支持)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/jugelizi.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    spec:
      dnsConfig:
        options:
          - name: single-request-reopen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加 options 还有其它一些方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在容器的 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 或者 &lt;code&gt;CMD&lt;/code&gt; 脚本中，执行 &lt;code&gt;/bin/echo &#39;options single-request-reopen&#39; &amp;gt;&amp;gt; /etc/resolv.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 postStart hook 里加:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;        lifecycle:
          postStart:
            exec:
              command:
              - /bin/sh
              - -c 
              - &amp;quot;/bin/echo &#39;options single-request-reopen&#39; &amp;gt;&amp;gt; /etc/resolv.conf&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook-beta-in-1-9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MutatingAdmissionWebhook&lt;/a&gt;，这是 1.9 引入的 Controller，用于对一个指定的资源的操作之前，对这个资源进行变更。 istio 的自动 sidecar 注入就是用这个功能来实现的，我们也可以通过 &lt;code&gt;MutatingAdmissionWebhook&lt;/code&gt; 来自动给所有 Pod 注入 &lt;code&gt;resolv.conf&lt;/code&gt; 文件，不过需要一定的开发量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决方案三: 使用本地 DNS 缓存&lt;/p&gt;
&lt;p&gt;仔细观察可以看到前面两种方案是 glibc 支持的，而基于 alpine 的镜像底层库是 musl libc 不是 glibc，所以即使加了这些 options 也没用，这种情况可以考虑使用本地 DNS 缓存来解决，容器的 DNS 请求都发往本地的 DNS 缓存服务(dnsmasq, nscd, coredns等)，不需要走 DNAT，也不会发生 conntrack 冲突。另外还有个好处，就是避免 DNS 服务成为性能瓶颈。&lt;/p&gt;
&lt;p&gt;使用本地DNS缓存有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个容器自带一个 DNS 缓存服务&lt;/li&gt;
&lt;li&gt;每个节点运行一个 DNS 缓存服务，所有容器都把本节点的 DNS 缓存作为自己的 nameserver&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从资源效率的角度来考虑的话，推荐后一种方式。&lt;/p&gt;
&lt;p&gt;官方也意识到了这个问题比较常见，给出了 coredns 以 cache 模式作为 daemonset 部署的解决方案: &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/nodelocaldns/&#34;&gt;https://kubernetes.io/docs/tasks/administer-cluster/nodelocaldns/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;pod-访问另一个集群的-apiserver-有延时&#34;&gt;Pod 访问另一个集群的 apiserver 有延时&lt;/h2&gt;
&lt;p&gt;现象：集群 a 的 Pod 内通过 kubectl 访问集群 b 的内网地址，偶尔出现延时的情况，但直接在宿主机上用同样的方法却没有这个问题。&lt;/p&gt;
&lt;p&gt;提炼环境和现象精髓:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 pod 内将另一个集群 apiserver 的 ip 写到了 hosts，因为 TKE apiserver 开启内网集群外内网访问创建的内网 LB 暂时没有支持自动绑内网 DNS 域名解析，所以集群外的内网访问 apiserver 需要加 hosts&lt;/li&gt;
&lt;li&gt;pod 内执行 kubectl 访问另一个集群偶尔延迟 5s，有时甚至10s&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;观察到 5s 延时，感觉跟之前 conntrack 的丢包导致 dns 解析 5s 延时有关，但是加了 hosts 呀，怎么还去解析域名？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/emoji_analysis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;进入 pod netns 抓包: 执行 kubectl 时确实有 dns 解析，并且发生延时的时候 dns 请求没有响应然后做了重试。&lt;/p&gt;
&lt;p&gt;看起来延时应该就是之前已知 conntrack 丢包导致 dns 5s 超时重试导致的。但是为什么会去解析域名? 明明配了 hosts 啊，正常情况应该是优先查找 hosts，没找到才去请求 dns 呀，有什么配置可以控制查找顺序?&lt;/p&gt;
&lt;p&gt;搜了一下发现: &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; 可以控制，但看有问题的 pod 里没有这个文件。然后观察到有问题的 pod 用的 alpine 镜像，试试其它镜像后发现只有基于 alpine 的镜像才会有这个问题。&lt;/p&gt;
&lt;p&gt;再一搜发现: musl libc 并不会使用 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; ，也就是说 alpine 镜像并没有实现用这个文件控制域名查找优先顺序，瞥了一眼 musl libc 的 &lt;code&gt;gethostbyname&lt;/code&gt; 和 &lt;code&gt;getaddrinfo&lt;/code&gt; 的实现，看起来也没有读这个文件来控制查找顺序，写死了先查 hosts，没找到再查 dns。&lt;/p&gt;
&lt;p&gt;这么说，那还是该先查 hosts 再查 dns 呀，为什么这里抓包看到是先查的 dns? (如果是先查 hosts 就能命中查询，不会再发起dns请求)&lt;/p&gt;
&lt;p&gt;访问 apiserver 的 client 是 kubectl，用 go 写的，会不会是 go 程序解析域名时压根没调底层 c 库的 &lt;code&gt;gethostbyname&lt;/code&gt; 或 &lt;code&gt;getaddrinfo&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/physical_analysis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;搜一下发现果然是这样: go runtime 用 go 实现了 glibc 的 &lt;code&gt;getaddrinfo&lt;/code&gt; 的行为来解析域名，减少了 c 库调用 (应该是考虑到减少 cgo 调用带来的的性能损耗)&lt;/p&gt;
&lt;p&gt;issue: &lt;a href=&#34;https://github.com/golang/go/issues/18518&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;net: replicate DNS resolution behaviour of getaddrinfo(glibc) in the go dns resolver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻源码验证下:&lt;/p&gt;
&lt;p&gt;Unix 系的 OS 下，除了 openbsd， go runtime 会读取 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; (&lt;code&gt;net/conf.go&lt;/code&gt;):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/nsswitch.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hostLookupOrder&lt;/code&gt; 函数决定域名解析顺序的策略，Linux 下，如果没有 &lt;code&gt;nsswitch.conf&lt;/code&gt; 文件就 dns 比 hosts 文件优先 (&lt;code&gt;net/conf.go&lt;/code&gt;):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/hostLookupOrder.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到 &lt;code&gt;hostLookupDNSFiles&lt;/code&gt; 的意思是 dns first (&lt;code&gt;net/dnsclient_unix.go&lt;/code&gt;):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/hostLookupDNSFiles.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以虽然 alpine 用的 musl libc 不是 glibc，但 go 程序解析域名还是一样走的 glibc 的逻辑，而 alpine 没有 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; 文件，也就解释了为什么 kubectl 访问 apiserver 先做 dns 解析，没解析到再查的 hosts，导致每次访问都去请求 dns，恰好又碰到 conntrack 那个丢包问题导致 dns 5s 延时，在用户这里表现就是 pod 内用 kubectl 访问 apiserver 偶尔出现 5s 延时，有时出现 10s 是因为重试的那次 dns 请求刚好也遇到 conntrack 丢包导致延时又叠加了 5s 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/emoji_jizhi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;解决方案:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;换基础镜像，不用 alpine&lt;/li&gt;
&lt;li&gt;挂载 &lt;code&gt;nsswitch.conf&lt;/code&gt; 文件 (可以用 hostPath)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dns-解析异常&#34;&gt;DNS 解析异常&lt;/h2&gt;
&lt;p&gt;现象: 有个用户反馈域名解析有时有问题，看报错是解析超时。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/emoji_analysis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一反应当然是看 coredns 的 log:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[ERROR] 2 loginspub.xxxxmobile-inc.net. 
A: unreachable backend: read udp 172.16.0.230:43742-&amp;gt;10.225.30.181:53: i/o timeout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是上游 DNS 解析异常了，因为解析外部域名 coredns 默认会请求上游 DNS 来查询，这里的上游 DNS 默认是 coredns pod 所在宿主机的 &lt;code&gt;resolv.conf&lt;/code&gt; 里面的 nameserver (coredns pod 的 dnsPolicy 为 &amp;ldquo;Default&amp;rdquo;，也就是会将宿主机里的 &lt;code&gt;resolv.conf&lt;/code&gt; 里的 nameserver 加到容器里的 &lt;code&gt;resolv.conf&lt;/code&gt;, coredns 默认配置 &lt;code&gt;proxy . /etc/resolv.conf&lt;/code&gt;, 意思是非 service 域名会使用 coredns 容器中 &lt;code&gt;resolv.conf&lt;/code&gt; 文件里的 nameserver 来解析)&lt;/p&gt;
&lt;p&gt;确认了下，超时的上游 DNS 10.225.30.181 并不是期望的 nameserver，VPC 默认 DNS 应该是 180 开头的。看了 coredns 所在节点的 &lt;code&gt;resolv.conf&lt;/code&gt;，发现确实多出了这个非期望的 nameserver，跟用户确认了下，这个 DNS 不是用户自己加上去的，添加节点时这个 nameserver 本身就在 &lt;code&gt;resolv.conf&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;根据内部同学反馈， 10.225.30.181 是广州一台年久失修将被撤裁的 DNS，物理网络，没有 VIP，撤掉就没有了，所以如果 coredns 用到了这台 DNS 解析时就可能 timeout。后面我们自己测试，某些 VPC 的集群确实会有这个 nameserver，奇了怪了，哪里冒出来的？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/cooldown_analysis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;又试了下直接创建 CVM，不加进 TKE 节点发现没有这个 nameserver，只要一加进 TKE 节点就有了 !!!&lt;/p&gt;
&lt;p&gt;看起来是 TKE 的问题，将 CVM 添加到 TKE 集群会自动重装系统，初始化并加进集群成为 K8S 的 node，确认了初始化过程并不会写 &lt;code&gt;resolv.conf&lt;/code&gt;，会不会是 TKE 的 OS 镜像问题？尝试搜一下除了 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 之外哪里还有这个 nameserver 的 IP，最后发现 &lt;code&gt;/etc/resolvconf/resolv.conf.d/base&lt;/code&gt; 这里面有。&lt;/p&gt;
&lt;p&gt;看下 &lt;code&gt;/etc/resolvconf/resolv.conf.d/base&lt;/code&gt; 的作用：Ubuntu 的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 是动态生成的，每次重启都会将 &lt;code&gt;/etc/resolvconf/resolv.conf.d/base&lt;/code&gt;  里面的内容加到 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 里。&lt;/p&gt;
&lt;p&gt;经确认: 这个文件确实是 TKE 的 Ubuntu OS 镜像里自带的，可能发布 OS 镜像时不小心加进去的。&lt;/p&gt;
&lt;p&gt;那为什么有些 VPC 的集群的节点 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 里面没那个 IP 呢？它们的 OS 镜像里也都有那个文件那个 IP 呀。&lt;/p&gt;
&lt;p&gt;请教其它部门同学发现:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非 dhcp 子机，cvm 的 cloud-init 会覆盖 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 来设置 dns&lt;/li&gt;
&lt;li&gt;dhcp 子机，cloud-init 不会设置，而是通过 dhcp 动态下发&lt;/li&gt;
&lt;li&gt;2018 年 4 月 之后创建的 VPC 就都是 dhcp 类型了的，比较新的 VPC 都是 dhcp 类型的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;真相大白：&lt;code&gt;/etc/resolv.conf&lt;/code&gt; 一开始内容都包含 &lt;code&gt;/etc/resolvconf/resolv.conf.d/base&lt;/code&gt; 的内容，也就是都有那个不期望的 nameserver，但老的 VPC 由于不是 dhcp 类型，所以 cloud-init 会覆盖 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，抹掉了不被期望的 nameserver，而新创建的 VPC 都是 dhcp 类型，cloud-init 不会覆盖 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，导致不被期望的 nameserver 残留在了 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，而 coredns pod 的 dnsPolicy 为 “Default”，也就是会将宿主机的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 中的 nameserver 加到容器里，coredns 解析集群外的域名默认使用这些 nameserver 来解析，当用到那个将被撤裁的 nameserver 就可能 timeout。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/emoji_jizhi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;临时解决: 删掉 &lt;code&gt;/etc/resolvconf/resolv.conf.d/base&lt;/code&gt;  重启&lt;/p&gt;
&lt;p&gt;长期解决: 我们重新制作 TKE Ubuntu OS 镜像然后发布更新&lt;/p&gt;
&lt;p&gt;这下应该没问题了吧，But, 用户反馈还是会偶尔解析有问题，但现象不一样了，这次并不是 dns timeout。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/chijing1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;用脚本跑测试仔细分析现象:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求 &lt;code&gt;loginspub.xxxxmobile-inc.net&lt;/code&gt; 时，偶尔提示域名无法解析&lt;/li&gt;
&lt;li&gt;请求 &lt;code&gt;accounts.google.com&lt;/code&gt; 时，偶尔提示连接失败&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入 dns 解析偶尔异常的容器的 netns 抓包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dns 请求会并发请求 A 和 AAAA 记录&lt;/li&gt;
&lt;li&gt;测试脚本发请求打印序号，抓包然后 wireshark 分析对比异常时请求序号偏移量，找到异常时的 dns 请求报文，发现异常时 A 和 AAAA 记录的请求 id 冲突，并且 AAAA 响应先返回&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/dns-id-conflict.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;正常情况下id不会冲突，这里冲突了也就能解释这个 dns 解析异常的现象了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;loginspub.xxxxmobile-inc.net&lt;/code&gt; 没有 AAAA (ipv6) 记录，它的响应先返回告知 client 不存在此记录，由于请求 id 跟 A 记录请求冲突，后面 A 记录响应返回了 client 发现 id 重复就忽略了，然后认为这个域名无法解析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;accounts.google.com&lt;/code&gt; 有 AAAA 记录，响应先返回了，client 就拿这个记录去尝试请求，但当前容器环境不支持 ipv6，所以会连接失败&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那为什么 dns 请求 id 会冲突?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/chengsi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;继续观察发现: 其它节点上的 pod 不会复现这个问题，有问题这个节点上也不是所有 pod 都有这个问题，只有基于 alpine 镜像的容器才有这个问题，在此节点新起一个测试的 &lt;code&gt;alpine:latest&lt;/code&gt; 的容器也一样有这个问题。&lt;/p&gt;
&lt;p&gt;为什么 alpine 镜像的容器在这个节点上有问题在其它节点上没问题？ 为什么其他镜像的容器都没问题？它们跟 alpine 的区别是什么？&lt;/p&gt;
&lt;p&gt;发现一点区别: alpine 使用的底层 c 库是 musl libc，其它镜像基本都是 glibc&lt;/p&gt;
&lt;p&gt;翻 musl libc 源码, 构造 dns 请求时，请求 id 的生成没加锁，而且跟当前时间戳有关:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/musl-libc-make-dns-query.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;看注释，作者应该认为这样id基本不会冲突，事实证明，绝大多数情况确实不会冲突，我在网上搜了很久没有搜到任何关于 musl libc 的 dns 请求 id 冲突的情况。这个看起来取决于硬件，可能在某种类型硬件的机器上运行，短时间内生成的 id 就可能冲突。我尝试跟用户在相同地域的集群，添加相同配置相同机型的节点，也复现了这个问题，但后来删除再添加时又不能复现了，看起来后面新建的 cvm 又跑在了另一种硬件的母机上了。&lt;/p&gt;
&lt;p&gt;OK，能解释通了，再底层的细节就不清楚了，我们来看下解决方案:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;换基础镜像 (不用alpine)&lt;/li&gt;
&lt;li&gt;完全静态编译业务程序(不依赖底层c库)，比如go语言程序编译时可以关闭 cgo (CGO_ENABLED=0)，并告诉链接器要静态链接 (&lt;code&gt;go build&lt;/code&gt; 后面加 &lt;code&gt;-ldflags &#39;-d&#39;&lt;/code&gt;)，但这需要语言和编译工具支持才可以&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终建议用户基础镜像换成另一个比较小的镜像: &lt;code&gt;debian:stretch-slim&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;pod-偶尔存活检查失败&#34;&gt;Pod 偶尔存活检查失败&lt;/h2&gt;
&lt;p&gt;现象: Pod 偶尔会存活检查失败，导致 Pod 重启，业务偶尔连接异常。&lt;/p&gt;
&lt;p&gt;之前从未遇到这种情况，在自己测试环境尝试复现也没有成功，只有在用户这个环境才可以复现。这个用户环境流量较大，感觉跟连接数或并发量有关。&lt;/p&gt;
&lt;p&gt;用户反馈说在友商的环境里没这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/emoji_analysis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;对比友商的内核参数发现有些区别，尝试将节点内核参数改成跟友商的一样，发现问题没有复现了。&lt;/p&gt;
&lt;p&gt;再对比分析下内核参数差异，最后发现是 backlog 太小导致的，节点的 &lt;code&gt;net.ipv4.tcp_max_syn_backlog&lt;/code&gt; 默认是 1024，如果短时间内并发新建 TCP 连接太多，SYN 队列就可能溢出，导致部分新连接无法建立。&lt;/p&gt;
&lt;p&gt;解释一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/backlog.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;TCP 连接建立会经过三次握手，server 收到 SYN 后会将连接加入 SYN 队列，当收到最后一个 ACK 后连接建立，这时会将连接从 SYN 队列中移动到 ACCEPT 队列。在 SYN 队列中的连接都是没有建立完全的连接，处于半连接状态。如果 SYN 队列比较小，而短时间内并发新建的连接比较多，同时处于半连接状态的连接就多，SYN 队列就可能溢出，&lt;code&gt;tcp_max_syn_backlog&lt;/code&gt; 可以控制 SYN 队列大小，用户节点的 backlog 大小默认是 1024，改成 8096 后就可以解决问题。&lt;/p&gt;
&lt;h2 id=&#34;访问-externaltrafficpolicy-为-local-的-service-对应-lb-有时超时&#34;&gt;访问 externalTrafficPolicy 为 Local 的 Service 对应 LB 有时超时&lt;/h2&gt;
&lt;p&gt;现象：用户在 TKE 创建了公网 LoadBalancer 类型的 Service，externalTrafficPolicy 设为了 Local，访问这个 Service 对应的公网 LB 有时会超时。&lt;/p&gt;
&lt;p&gt;externalTrafficPolicy 为 Local 的 Service 用于在四层获取客户端真实源 IP，官方参考文档：&lt;a href=&#34;https://kubernetes.io/docs/tutorials/services/source-ip/#source-ip-for-services-with-type-loadbalancer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Source IP for Services with Type=LoadBalancer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;TKE 的 LoadBalancer 类型 Service 实现是使用 CLB 绑定所有节点对应 Service 的 NodePort，CLB 不做 SNAT，报文转发到 NodePort 时源 IP 还是真实的客户端 IP，如果 NodePort 对应 Service 的 externalTrafficPolicy 不是 Local 的就会做 SNAT，到 pod 时就看不到客户端真实源 IP 了，但如果是 Local 的话就不做 SNAT，如果本机 node 有这个 Service 的 endpoint 就转到对应 pod，如果没有就直接丢掉，因为如果转到其它 node 上的 pod 就必须要做 SNAT，不然无法回包，而 SNAT 之后就无法获取真实源 IP 了。&lt;/p&gt;
&lt;p&gt;LB 会对绑定节点的 NodePort 做健康检查探测，检查 LB 的健康检查状态: 发现这个 NodePort 的所有节点都不健康 !!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/chijing1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么会全不健康，这个 Service 有对应的 pod 实例，有些节点上是有 endpoint 的，为什么它们也不健康?&lt;/li&gt;
&lt;li&gt;LB 健康检查全不健康，但是为什么有时还是可以访问后端服务?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/smoke_cooldown.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;跟 LB 的同学确认: 如果后端 rs 全不健康会激活 LB 的全死全活逻辑，也就是所有后端 rs 都可以转发。&lt;/p&gt;
&lt;p&gt;那么有 endpoint 的 node 也是不健康这个怎么解释?&lt;/p&gt;
&lt;p&gt;在有 endpoint 的 node 上抓 NodePort 的包: 发现很多来自 LB 的 SYN，但是没有响应 ACK。&lt;/p&gt;
&lt;p&gt;看起来报文在哪被丢了，继续抓下 cbr0 看下: 发现没有来自 LB 的包，说明报文在 cbr0 之前被丢了。&lt;/p&gt;
&lt;p&gt;再观察用户集群环境信息:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;k8s 版本1.12&lt;/li&gt;
&lt;li&gt;启用了 ipvs&lt;/li&gt;
&lt;li&gt;只有 local 的 service 才有异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;尝试新建一个 1.12 启用 ipvs 和一个没启用 ipvs 的测试集群。也都创建 Local 的 LoadBalancer Service，发现启用 ipvs 的测试集群复现了那个问题，没启用 ipvs 的集群没这个问题。&lt;/p&gt;
&lt;p&gt;再尝试创建 1.10 的集群，也启用 ipvs，发现没这个问题。&lt;/p&gt;
&lt;p&gt;看起来跟集群版本和是否启用 ipvs 有关。&lt;/p&gt;
&lt;p&gt;1.12 对比 1.10 启用 ipvs 的集群: 1.12 的会将 LB 的 &lt;code&gt;EXTERNAL-IP&lt;/code&gt; 绑到 &lt;code&gt;kube-ipvs0&lt;/code&gt; 上，而 1.10 的不会:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ip a show kube-ipvs0 | grep -A2 170.106.134.124
    inet 170.106.134.124/32 brd 170.106.134.124 scope global kube-ipvs0
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;170.106.134.124 是 LB 的公网 IP&lt;/li&gt;
&lt;li&gt;1.12 启用 ipvs 的集群将 LB 的公网 IP 绑到了 &lt;code&gt;kube-ipvs0&lt;/code&gt; 网卡上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;kube-ipvs0&lt;/code&gt; 是一个 dummy interface，实际不会接收报文，可以看到它的网卡状态是 DOWN，主要用于绑 ipvs 规则的 VIP，因为 ipvs 主要工作在 netfilter 的 INPUT 链，报文通过 PREROUTING 链之后需要决定下一步该进入 INPUT 还是 FORWARD 链，如果是本机 IP 就会进入 INPUT，如果不是就会进入 FORWARD 转发到其它机器。所以 k8s 利用 &lt;code&gt;kube-ipvs0&lt;/code&gt; 这个网卡将 service 相关的 VIP 绑在上面以便让报文进入 INPUT 进而被 ipvs 转发。&lt;/p&gt;
&lt;p&gt;当 IP 被绑到 &lt;code&gt;kube-ipvs0&lt;/code&gt; 上，内核会自动将上面的 IP 写入 local 路由:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ip route show table local | grep 170.106.134.124
local 170.106.134.124 dev kube-ipvs0  proto kernel  scope host  src 170.106.134.124
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内核认为在 local 路由里的 IP 是本机 IP，而 linux 默认有个行为: 忽略任何来自非回环网卡并且源 IP 是本机 IP 的报文。而 LB 的探测报文源 IP 就是 LB IP，也就是 Service 的 &lt;code&gt;EXTERNAL-IP&lt;/code&gt; 猜想就是因为这个 IP 被绑到 &lt;code&gt;kube-ipvs0&lt;/code&gt;，自动加进 local 路由导致内核直接忽略了 LB 的探测报文。&lt;/p&gt;
&lt;p&gt;带着猜想做实现， 试一下将 LB IP 从 local 路由中删除:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ip route del table local local 170.106.134.124 dev kube-ipvs0  proto kernel  scope host  src 170.106.134.124
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;发现这个 node 的在 LB 的健康检查的状态变成健康了! 看来就是因为这个 LB IP 被绑到 &lt;code&gt;kube-ipvs0&lt;/code&gt; 导致内核忽略了来自 LB 的探测报文，然后 LB 收不到回包认为不健康。&lt;/p&gt;
&lt;p&gt;那为什么其它厂商没反馈这个问题？应该是 LB 的实现问题，腾讯云的公网 CLB 的健康探测报文源 IP 就是 LB 的公网 IP，而大多数厂商的 LB 探测报文源 IP 是保留 IP 并非 LB 自身的 VIP。&lt;/p&gt;
&lt;p&gt;如何解决呢? 发现一个内核参数:  &lt;a href=&#34;https://github.com/torvalds/linux/commit/8153a10c08f1312af563bb92532002e46d3f504a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;accept_local&lt;/a&gt; 可以让 linux 接收源 IP 是本机 IP 的报文。&lt;/p&gt;
&lt;p&gt;试了开启这个参数，确实在 cbr0 收到来自 LB 的探测报文了，说明报文能被 pod 收到，但抓 eth0 还是没有给 LB 回包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/meme/physical_analysis.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;为什么没有回包? 分析下五元组，要给 LB 回包，那么 &lt;code&gt;目的IP:目的Port&lt;/code&gt; 必须是探测报文的 &lt;code&gt;源IP:源Port&lt;/code&gt;，所以目的 IP 就是 LB IP，由于容器不在主 netns，发包经过 veth pair 到 cbr0 之后需要再经过 netfilter 处理，报文进入 PREROUTING 链然后发现目的 IP 是本机 IP，进入 INPUT 链，所以报文就出不去了。再分析下进入 INPUT 后会怎样，因为目的 Port 跟 LB 探测报文源 Port 相同，是一个随机端口，不在 Service 的端口列表，所以没有对应的 IPVS 规则，IPVS 也就不会转发它，而 &lt;code&gt;kube-ipvs0&lt;/code&gt; 上虽然绑了这个 IP，但它是一个 dummy interface，不会收包，所以报文最后又被忽略了。&lt;/p&gt;
&lt;p&gt;再看看为什么 1.12 启用 ipvs 会绑 &lt;code&gt;EXTERNAL-IP&lt;/code&gt; 到 &lt;code&gt;kube-ipvs0&lt;/code&gt;，翻翻 k8s 的 kube-proxy 支持 ipvs 的 &lt;a href=&#34;https://github.com/kubernetes/enhancements/blob/baca87088480254b26d0fdeb26303d7c51a20fbd/keps/sig-network/0011-ipvs-proxier.md#support-loadbalancer-service&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proposal&lt;/a&gt;，发现有个地方说法有点漏洞:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/ipvs-proposal.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;LB 类型 Service 的 status 里有 ingress IP，实际就是 &lt;code&gt;kubectl get service&lt;/code&gt; 看到的 &lt;code&gt;EXTERNAL-IP&lt;/code&gt;，这里说不会绑定这个 IP 到 kube-ipvs0，但后面又说会给它创建 ipvs 规则，既然没有绑到 &lt;code&gt;kube-ipvs0&lt;/code&gt;，那么这个 IP 的报文根本不会进入 INPUT 被 ipvs 模块转发，创建的 ipvs 规则也是没用的。&lt;/p&gt;
&lt;p&gt;后来找到作者私聊，思考了下，发现设计上确实有这个问题。&lt;/p&gt;
&lt;p&gt;看了下 1.10 确实也是这么实现的，但是为什么 1.12 又绑了这个 IP 呢? 调研后发现是因为 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/59976&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#59976&lt;/a&gt;  这个 issue 发现一个问题，后来引入 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/63066&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#63066&lt;/a&gt; 这个 PR 修复的，而这个 PR 的行为就是让 LB IP 绑到 &lt;code&gt;kube-ipvs0&lt;/code&gt;，这个提交影响 1.11 及其之后的版本。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/59976&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#59976&lt;/a&gt; 的问题是因为没绑 LB IP到 &lt;code&gt;kube-ipvs0&lt;/code&gt; 上，在自建集群使用 &lt;code&gt;MetalLB&lt;/code&gt; 来实现 LoadBalancer 类型的 Service，而有些网络环境下，pod 是无法直接访问 LB 的，导致 pod 访问 LB IP 时访问不了，而如果将 LB IP 绑到 &lt;code&gt;kube-ipvs0&lt;/code&gt; 上就可以通过 ipvs 转发到 LB 类型 Service 对应的 pod 去， 而不需要真正经过 LB，所以引入了 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/63066&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#63066&lt;/a&gt; 这个PR。&lt;/p&gt;
&lt;p&gt;临时方案: 将 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/63066&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#63066&lt;/a&gt; 这个 PR 的更改回滚下，重新编译 kube-proxy，提供升级脚本升级存量 kube-proxy。&lt;/p&gt;
&lt;p&gt;如果是让 LB 健康检查探测支持用保留 IP 而不是自身的公网 IP ，也是可以解决，但需要跨团队合作，而且如果多个厂商都遇到这个问题，每家都需要为解决这个问题而做开发调整，代价较高，所以长期方案需要跟社区沟通一起推进，所以我提了 issue，将问题描述的很清楚: &lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/79783&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#79783&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小思考: 为什么 CLB 可以不做 SNAT ? 回包目的 IP 就是真实客户端 IP，但客户端是直接跟 LB IP 建立的连接，如果回包不经过 LB 是不可能发送成功的呀。&lt;/p&gt;
&lt;p&gt;是因为 CLB 的实现是在母机上通过隧道跟 CVM 互联的，多了一层封装，回包始终会经过 LB。&lt;/p&gt;
&lt;p&gt;就是因为 CLB 不做 SNAT，正常来自客户端的报文是可以发送到 nodeport，但健康检查探测报文由于源 IP 是 LB IP 被绑到 &lt;code&gt;kube-ipvs0&lt;/code&gt; 导致被忽略，也就解释了为什么健康检查失败，但通过LB能访问后端服务，只是有时会超时。那么如果要做 SNAT 的 LB 岂不是更糟糕，所有报文都变成 LB IP，所有报文都会被忽略?&lt;/p&gt;
&lt;p&gt;我提的 issue 有回复指出，AWS 的 LB 会做 SNAT，但它们不将 LB 的 IP 写到 Service 的 Status 里，只写了 hostname，所以也不会绑 LB IP 到 &lt;code&gt;kube-ipvs0&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/aws-lb-snat.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是只写 hostname 也得 LB 支持自动绑域名解析，并且个人觉得只写 hostname 很别扭，通过 &lt;code&gt;kubectl get svc&lt;/code&gt; 或者其它 k8s 管理系统无法直接获取 LB IP，这不是一个好的解决方法。&lt;/p&gt;
&lt;p&gt;我提了 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/79976&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;#79976&lt;/a&gt; 这个 PR 可以解决问题: 给 kube-proxy 加 &lt;code&gt;--exclude-external-ip&lt;/code&gt; 这个 flag 控制是否为 LB IP
创建 ipvs 规则和绑定 &lt;code&gt;kube-ipvs0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但有人担心增加 kube-proxy flag 会增加 kube-proxy 的调试复杂度，看能否在 iptables 层面解决:
&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/solve-in-iptables.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;仔细一想，确实可行，打算有空实现下，重新提个 PR:
&lt;img src=&#34;https://imroc.io/assets/blog/troubleshooting-k8s-network/solve-in-prerouting.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;至此，我们一起完成了一段奇妙的问题排查之旅，信息量很大并且比较复杂，有些没看懂很正常，但我希望你可以收藏起来反复阅读，一起在技术的道路上打怪升级。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes 最佳实践：解决长连接服务扩容失效</title>
      <link>/post/201906/kubernetes-scale-keepalive-service/</link>
      <pubDate>Thu, 06 Jun 2019 17:06:00 +0800</pubDate>
      <guid>/post/201906/kubernetes-scale-keepalive-service/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;&lt;/nav&gt;
&lt;/details&gt;
&lt;p&gt;在现网运营中，有很多场景为了提高效率，一般都采用建立长连接的方式来请求。我们发现在客户端以长连接请求服务端的场景下，K8S的自动扩容会失效。原因是客户端长连接一直保留在老的Pod容器中，新扩容的Pod没有新的连接过来，导致K8S按照步长扩容第一批Pod之后就停止了扩容操作，而且新扩容的Pod没能承载请求，进而出现服务过载的情况，自动扩容失去了意义。&lt;/p&gt;
&lt;p&gt;对长连接扩容失效的问题，我们的解决方法是将长连接转换为短连接。我们参考了 nginx keepalive 的设计，nginx 中 keepalive_requests 这个配置项设定了一个TCP连接能处理的最大请求数，达到设定值(比如1000)之后服务端会在 http 的 Header 头标记 “&lt;code&gt;Connection:close&lt;/code&gt;”，通知客户端处理完当前的请求后关闭连接，新的请求需要重新建立TCP连接，所以这个过程中不会出现请求失败，同时又达到了将长连接按需转换为短连接的目的。通过这个办法客户端和云K8S服务端处理完一批请求后不断的更新TCP连接，自动扩容的新Pod能接收到新的连接请求，从而解决了自动扩容失效的问题。&lt;/p&gt;
&lt;p&gt;由于Golang并没有提供方法可以获取到每个连接处理过的请求数，我们重写了 &lt;code&gt;net.Listener&lt;/code&gt; 和 &lt;code&gt;net.Conn&lt;/code&gt;，注入请求计数器，对每个连接处理的请求做计数，并通过 &lt;code&gt;net.Conn.LocalAddr()&lt;/code&gt; 获得计数值，判断达到阈值 1000 后在返回的 Header 中插入 “&lt;code&gt;Connection:close&lt;/code&gt;” 通知客户端关闭连接，重新建立连接来发起请求。以上处理逻辑用 Golang 实现示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;net&amp;quot;
	&amp;quot;github.com/gin-gonic/gin&amp;quot;
	&amp;quot;net/http&amp;quot;
)

//重新定义net.Listener
type counterListener struct {
	net.Listener
}

//重写net.Listener.Accept(),对接收到的连接注入请求计数器
func (c *counterListener) Accept() (net.Conn, error) {
	conn, err := c.Listener.Accept()
	if err != nil {
		return nil, err
	}
	return &amp;amp;counterConn{Conn: conn}, nil
}

//定义计数器counter和计数方法Increment()
type counter int

func (c *counter) Increment() int {
	*c++
	return int(*c)
}

//重新定义net.Conn,注入计数器ct
type counterConn struct {
	net.Conn
	ct counter
}

//重写net.Conn.LocalAddr()，返回本地网络地址的同时返回该连接累计处理过的请求数
func (c *counterConn) LocalAddr() net.Addr {
	return &amp;amp;counterAddr{c.Conn.LocalAddr(), &amp;amp;c.ct}
}

//定义TCP连接计数器,指向连接累计请求的计数器
type counterAddr struct {
	net.Addr
	*counter
}

func main() {
	r := gin.New()
	r.Use(func(c *gin.Context) {
		localAddr := c.Request.Context().Value(http.LocalAddrContextKey)
		if ct, ok := localAddr.(interface{ Increment() int }); ok {
			if ct.Increment() &amp;gt;= 1000 {
				c.Header(&amp;quot;Connection&amp;quot;, &amp;quot;close&amp;quot;)
			}
		}
		c.Next()
	})
	r.GET(&amp;quot;/&amp;quot;, func(c *gin.Context) {
		c.String(200, &amp;quot;plain/text&amp;quot;, &amp;quot;hello&amp;quot;)
	})
	l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:8080&amp;quot;)
	if err != nil {
		panic(err)
	}
	err = http.Serve(&amp;amp;counterListener{l}, r)
	if err != nil {
		panic(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 泛域名动态 Service 转发解决方案</title>
      <link>/post/201812/kubernetes-wildcard-domain-forward/</link>
      <pubDate>Sat, 22 Dec 2018 01:09:00 +0800</pubDate>
      <guid>/post/201812/kubernetes-wildcard-domain-forward/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#需求&#34;&gt;需求&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#简单做法&#34;&gt;简单做法&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#正确姿势&#34;&gt;正确姿势&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h3 id=&#34;需求&#34;&gt;需求&lt;/h3&gt;
&lt;p&gt;集群对外暴露了一个公网IP作为流量入口(可以是 Ingress 或 Service)，DNS 解析配置了一个泛域名指向该IP（比如 &lt;code&gt;*.test.imroc.io&lt;/code&gt;），现希望根据请求中不同 Host 转发到不同的后端 Service。比如 &lt;code&gt;a.test.imroc.io&lt;/code&gt; 的请求被转发到 &lt;code&gt;my-svc-a&lt;/code&gt;，&lt;code&gt;b.test.imroc.io&lt;/code&gt; 的请求转发到 &lt;code&gt;my-svc-b&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;简单做法&#34;&gt;简单做法&lt;/h3&gt;
&lt;p&gt;先说一种简单的方法，这也是大多数人的第一反应：&lt;strong&gt;配置 Ingress 规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假如泛域名有两个不同 Host 分别转发到不同 Service，Ingress 类似这样写:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: my-ingress
spec:
  rules:
  - host: a.test.imroc.io
    http:
      paths:
      - backend:
          serviceName: my-svc-a
          servicePort: 80
        path: /
  - host: b.test.imroc.io
    http:
      paths:
      - backend:
          serviceName: my-svc-b
          servicePort: 80
        path: /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是！如果 Host 非常多会怎样？（比如200+）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次新增 Host 都要改 Ingress 规则，太麻烦&lt;/li&gt;
&lt;li&gt;单个 Ingress 上面的规则越来越多，更改规则对 LB 的压力变大，可能会导致偶尔访问不了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;正确姿势&#34;&gt;正确姿势&lt;/h3&gt;
&lt;p&gt;我们可以约定请求中泛域名 Host 通配符的 &lt;code&gt;*&lt;/code&gt; 号匹配到的字符跟 Service 的名字相关联（可以是相等，或者 Service 统一在前面加个前缀，比如 &lt;code&gt;a.test.imroc.io&lt;/code&gt; 转发到 &lt;code&gt;my-svc-a&lt;/code&gt; 这个 Service)，集群内起一个反向代理服务，匹配泛域名的请求全部转发到这个代理服务上，这个代理服务只做一件简单的事，解析 Host，正则匹配抓取泛域名中 &lt;code&gt;*&lt;/code&gt; 号这部分，把它转换为 Service 名字，然后在集群里转发（集群 DNS 解析)&lt;/p&gt;
&lt;p&gt;这个反向代理服务可以是 Nginx+Lua脚本 来实现，或者自己写个简单程序来做反向代理，这里我用 &lt;a href=&#34;https://openresty.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenResty&lt;/a&gt; 来实现，它可以看成是 Nginx 的发行版，自带 lua 支持。&lt;/p&gt;
&lt;p&gt;有几点需要说明下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们使用 nginx 的  &lt;code&gt;proxy_pass&lt;/code&gt; 来反向代理到后端服务，&lt;code&gt;proxy_pass&lt;/code&gt; 后面跟的变量，我们需要用 lua 来判断 Host 修改变量&lt;/li&gt;
&lt;li&gt;nginx 的 &lt;code&gt;proxy_pass&lt;/code&gt; 后面跟的如果是可变的域名（非IP，需要 dns 解析)，它需要一个域名解析器，不会走默认的 dns 解析，需要在 &lt;code&gt;nginx.conf&lt;/code&gt; 里添加 &lt;code&gt;resolver&lt;/code&gt; 配置项来设置一个外部的 dns 解析器&lt;/li&gt;
&lt;li&gt;这个解析器我们是用 go-dnsmasq 来实现，它可以将集群的 dns 解析代理给 nginx，以 sidecar 的形式注入到 pod 中，监听 53 端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;nginx.conf&lt;/code&gt; 里关键的配置如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://imroc.io/assets/blog/nginx-wilcard-conf.png&#34; alt=&#34;nginx.conf&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面给出完整的 yaml 示例&lt;/p&gt;
&lt;p&gt;&lt;code&gt;proxy.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1beta1
kind: Deployment
metadata:
  labels:
    component: nginx
  name: proxy
spec:
  replicas: 1
  selector:
    matchLabels:
      component: nginx
  template:
    metadata:
      labels:
        component: nginx
    spec:
      containers:
      - name: nginx
        image: &amp;quot;openresty/openresty:centos&amp;quot;
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        volumeMounts:
        - mountPath: /usr/local/openresty/nginx/conf/nginx.conf
          name: config
          subPath: nginx.conf
      - name: dnsmasq
        image: &amp;quot;janeczku/go-dnsmasq:release-1.0.7&amp;quot;
        args:
          - --listen
          - &amp;quot;127.0.0.1:53&amp;quot;
          - --default-resolver
          - --append-search-domains
          - --hostsfile=/etc/hosts
          - --verbose
      volumes:
      - name: config
        configMap:
          name: configmap-nginx

---

apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    component: nginx
  name: configmap-nginx
data:
  nginx.conf: |-
    worker_processes  1;

    error_log  /error.log;

    events {
        accept_mutex on;
        multi_accept on;
        use epoll;
        worker_connections  1024;
    }


    http {
        include       mime.types;
        default_type  application/octet-stream;
        log_format  main  &#39;$time_local $remote_user $remote_addr $host $request_uri $request_method $http_cookie &#39;
                          &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                          &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot; &#39;
                          &#39;$request_time $upstream_response_time &amp;quot;$upstream_cache_status&amp;quot;&#39;;

        log_format  browser &#39;$time_iso8601 $cookie_km_uid $remote_addr $host $request_uri $request_method &#39;
                          &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                          &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot; &#39;
                          &#39;$request_time $upstream_response_time &amp;quot;$upstream_cache_status&amp;quot; $http_x_requested_with $http_x_real_ip $upstream_addr $request_body&#39;;

        log_format client &#39;{&amp;quot;@timestamp&amp;quot;:&amp;quot;$time_iso8601&amp;quot;,&#39;
                          &#39;&amp;quot;time_local&amp;quot;:&amp;quot;$time_local&amp;quot;,&#39;
                          &#39;&amp;quot;remote_user&amp;quot;:&amp;quot;$remote_user&amp;quot;,&#39;
                          &#39;&amp;quot;http_x_forwarded_for&amp;quot;:&amp;quot;$http_x_forwarded_for&amp;quot;,&#39;
                          &#39;&amp;quot;host&amp;quot;:&amp;quot;$server_addr&amp;quot;,&#39;
                          &#39;&amp;quot;remote_addr&amp;quot;:&amp;quot;$remote_addr&amp;quot;,&#39;
                          &#39;&amp;quot;http_x_real_ip&amp;quot;:&amp;quot;$http_x_real_ip&amp;quot;,&#39;
                          &#39;&amp;quot;body_bytes_sent&amp;quot;:$body_bytes_sent,&#39;
                          &#39;&amp;quot;request_time&amp;quot;:$request_time,&#39;
                          &#39;&amp;quot;status&amp;quot;:$status,&#39;
                          &#39;&amp;quot;upstream_response_time&amp;quot;:&amp;quot;$upstream_response_time&amp;quot;,&#39;
                          &#39;&amp;quot;upstream_response_status&amp;quot;:&amp;quot;$upstream_status&amp;quot;,&#39;
                          &#39;&amp;quot;request&amp;quot;:&amp;quot;$request&amp;quot;,&#39;
                          &#39;&amp;quot;http_referer&amp;quot;:&amp;quot;$http_referer&amp;quot;,&#39;
                          &#39;&amp;quot;http_user_agent&amp;quot;:&amp;quot;$http_user_agent&amp;quot;}&#39;;

        access_log  /access.log  main;

        sendfile        on;

        keepalive_timeout 120s 100s;
        keepalive_requests 500;
        send_timeout 60000s;
        client_header_buffer_size 4k;
        proxy_ignore_client_abort on;
        proxy_buffers 16 32k;
        proxy_buffer_size 64k;

        proxy_busy_buffers_size 64k;

        proxy_send_timeout 60000;
        proxy_read_timeout 60000;
        proxy_connect_timeout 60000;
        proxy_cache_valid 200 304 2h;
        proxy_cache_valid 500 404 2s;
        proxy_cache_key $host$request_uri$cookie_user;
        proxy_cache_methods GET HEAD POST;

        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_set_header Host                $http_host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;
        proxy_set_header X-Frame-Options     SAMEORIGIN;

        server_tokens off;
        client_max_body_size 50G;
        add_header X-Cache $upstream_cache_status;
        autoindex off;

        resolver      127.0.0.1:53 ipv6=off;
  
        server {
            listen 80;

            location / {
                set $service  &#39;&#39;;
                rewrite_by_lua &#39;
                    local host = ngx.var.host
                    local m = ngx.re.match(host, &amp;quot;(.+).test.imroc.io&amp;quot;)
                    if m then
                        ngx.var.service = &amp;quot;my-svc-&amp;quot; .. m[1]
                    end
                &#39;;
                proxy_pass http://$service;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;让该代理服务暴露公网访问可以用 Service 或 Ingress&lt;/p&gt;
&lt;p&gt;用 Service 的示例 (&lt;code&gt;service.yaml&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  labels:
    component: nginx
  name: service-nginx
spec:
  type: LoadBalancer
  ports:
  - name: http
    port: 80
    targetPort: http
  selector:
    component: nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用 Ingress 的示例 (&lt;code&gt;ingress.yaml&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress-nginx
spec:
  rules:
  - host: &amp;quot;*.test.imroc.io&amp;quot;
    http:
      paths:
      - backend:
          serviceName: service-nginx
          servicePort: 80
        path: /
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>极客工具之 Alfred 与 Dash</title>
      <link>/post/201810/alfred-and-dash/</link>
      <pubDate>Sun, 21 Oct 2018 07:00:00 +0800</pubDate>
      <guid>/post/201810/alfred-and-dash/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;目录&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#alfred&#34;&gt;Alfred&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#dash&#34;&gt;Dash&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#推荐系统快捷键&#34;&gt;推荐系统快捷键&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;alfred&#34;&gt;Alfred&lt;/h2&gt;
&lt;p&gt;使用 Alfred 可以让你在 macOS 程序间自由切换、快速查找或打开文件、调起浏览器进行网页搜索、 还可以做计算器。 另外，还有许多其它搜索功能以及付费的工作流特性，Powerpack 就是 Alfred 工作流模块，需要付费才能使用，不过，我觉得免费的功能已经完全够用了， 而且很简洁，功能太多咱也学不过来。&lt;/p&gt;
&lt;h4 id=&#34;下载安装&#34;&gt;下载安装&lt;/h4&gt;
&lt;p&gt;Alfred 官网是 &lt;a href=&#34;https://www.alfredapp.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.alfredapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;禁用自带的-spotlight&#34;&gt;禁用自带的 Spotlight&lt;/h4&gt;
&lt;p&gt;macOS 自带了搜索工具 Spotlight, 但是功能相对于 Alfred 就弱爆了，它默认的快捷键是 &lt;code&gt;cmd+space&lt;/code&gt;，我们最好禁用它，进入 &lt;code&gt;系统偏好设置-键盘-快捷键-聚焦&lt;/code&gt;，然后取消勾选 &lt;code&gt;显示“聚焦”搜索&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031377/blog/geek/alfred-disable-spotlight.png&#34; alt=&#34;alfred setting&#34;&gt;&lt;/p&gt;
&lt;p&gt;并且将 Alfred 的热键也设为 &lt;code&gt;cmd+space&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031375/blog/geek/alfred-setting.png&#34; alt=&#34;alfred setting&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;程序间快速切换&#34;&gt;程序间快速切换&lt;/h4&gt;
&lt;p&gt;我们之前常用的程序切换方式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cmd+tab 和 shift+cmd+tab 切换程序&lt;/li&gt;
&lt;li&gt;在触摸板三根手指上滑打开调度中心，结合三根手指左右滑切换桌面，然后选择要切换的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们的缺点很明显，程序窗口所在的位置不一定是固定的，需要观察一下才能找到，而且如果打开的程序非常多，找起来就更麻烦。如果用 Alfred， 则只需输入能匹配程序名称部分的简短字母就能找到（如果程序含中文名，使用拼音也能搜到)， 再按下回车就能切换到指定程序上，比如切换到 &lt;code&gt;Google Chrome&lt;/code&gt;，只需要输入 &lt;code&gt;chr&lt;/code&gt; 就能定位到 Chrome 浏览器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031373/blog/geek/alfred-search-app.png&#34; alt=&#34;search app&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;快速查找和打开文件或目录&#34;&gt;快速查找和打开文件或目录&lt;/h4&gt;
&lt;p&gt;Alfred 还支持很多指令，&lt;code&gt;find&lt;/code&gt; 是在磁盘找到文件，回车后就将搜到的文件或目录显示在 Finder 中，搜索是瞬间完成的，灰常灰常快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031373/blog/geek/alfred-find.png&#34; alt=&#34;aflred find&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;open&lt;/code&gt; 命令与 &lt;code&gt;find&lt;/code&gt; 类似，唯一的区别是 &lt;code&gt;open&lt;/code&gt; 会将文件直接通过默认的打开方式打开而不是显示在 &lt;code&gt;Finder&lt;/code&gt; 中。&lt;/p&gt;
&lt;h4 id=&#34;计算器&#34;&gt;计算器&lt;/h4&gt;
&lt;p&gt;偶尔我们需要做些数学计算，打开自带的计算器太麻烦，而且功能很弱，面对复杂的数学表达式输入显得不够直观简单，利用 Alfred 可以直接输入可读性很好的运算表达式，非常直观简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031373/blog/geek/alfred-calculator.png&#34; alt=&#34;aflred calculator&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;网页搜索&#34;&gt;网页搜索&lt;/h4&gt;
&lt;p&gt;没有输入命令的情况下，如果你的输入无法找到对应的程序，默认就会推荐到网页搜索&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031376/blog/geek/alfred-search-web.png&#34; alt=&#34;aflred search web&#34;&gt;&lt;/p&gt;
&lt;p&gt;你也可以一开始就指定用某个搜索引擎搜索，比如谷歌默认用的 &lt;code&gt;gg&lt;/code&gt; 命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031373/blog/geek/alfred-search-google.png&#34; alt=&#34;aflred search google&#34;&gt;&lt;/p&gt;
&lt;p&gt;你还可以自定义搜索引擎，比如百度、淘宝、京东、Github 等，以添加 Github 为例，打开 Alfred 的 &lt;code&gt;Preferences-Features-Web Search-Add Custom Search&lt;/code&gt;， 各选项填写如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Search URL: &lt;a href=&#34;https://github.com/search?q=%7Bquery%7D&#34;&gt;https://github.com/search?q={query}&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Title: Search with Github for {query}&lt;/li&gt;
&lt;li&gt;Keyword: gh&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031374/blog/geek/alfred-custom-search.png&#34; alt=&#34;aflred custom search&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{query}&lt;/code&gt; 是会填充的搜索词变量，随便在 Github 搜索一个关键词，然后复制 url ，将搜索词替换为 &lt;code&gt;{query}&lt;/code&gt; 就得到 &lt;code&gt;Search URL&lt;/code&gt; 了，其它搜索引擎的 &lt;code&gt;Search URL&lt;/code&gt; 也同理可得。&lt;/p&gt;
&lt;p&gt;现在在 Alfred 中输入 &lt;code&gt;gh&lt;/code&gt; 命令就可以搜索 Github 项目了，如果希望搜索的时候显示 Github 的 logo，可以自己把 logo 图片文件拖到上图设置右侧方框处。&lt;/p&gt;
&lt;h2 id=&#34;dash&#34;&gt;Dash&lt;/h2&gt;
&lt;p&gt;很多人应该都知道 Dash ，程序员看文档的神器，但其实它还有一个功能: &lt;code&gt;Snippets&lt;/code&gt;，这才是我频繁使用它的原因。它可以让你不受编辑器约束，在任意可以输入的地方都快速输入代码片段或者叫做文本模板，避免重复输入，提高效率。我会举一些实际使用的例子让你知道它为什么这么爽。&lt;/p&gt;
&lt;h4 id=&#34;下载安装-1&#34;&gt;下载安装&lt;/h4&gt;
&lt;p&gt;Dash 的官网是 &lt;a href=&#34;https://kapeli.com/dash&#34;&gt;https://kapeli.com/dash&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;确保-dash-权限&#34;&gt;确保 Dash 权限&lt;/h4&gt;
&lt;p&gt;进入 &lt;code&gt;系统偏好设置-键盘-快捷键-服务&lt;/code&gt;，确保搜索下面的 &lt;code&gt;Look Up in Dash&lt;/code&gt; 是勾选状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031374/blog/geek/dash-setting.png&#34; alt=&#34;dash setting&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;添加-snippet&#34;&gt;添加 Snippet&lt;/h4&gt;
&lt;p&gt;进入 Dash 的 Snippets，我们尝试添加一个，就拿我经常要输入的命令的举例&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031375/blog/geek/dash-snippets.png&#34; alt=&#34;dash snippets&#34;&gt;&lt;/p&gt;
&lt;p&gt;新建了一个名字是 &lt;code&gt;kx.&lt;/code&gt; 的 &lt;code&gt;Snippet&lt;/code&gt;，不管我们在哪输入了这个名字，他都会触发这个 &lt;code&gt;Snippet&lt;/code&gt;，我习惯用 &amp;ldquo;.&amp;rdquo; 号来触发，所以在名字默认都加了 &amp;ldquo;.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;来看下使用效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/imroc/image/upload/v1540031374/blog/geek/dash-demo.gif&#34; alt=&#34;dash demo&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了方便我们快速输入常用而又冗长的命令之外，你还可以把常用的服务器 ip 也做成 &lt;code&gt;Snippet&lt;/code&gt;，起个容易记得名字，这样你的服务器 ip 很多也不怕了， 不需要查服务器 ip 列表，直接输入 &lt;code&gt;Snippet&lt;/code&gt; 名称。你也可以把你的公钥也做成 &lt;code&gt;Snippet&lt;/code&gt;，这样就可以很方便把公钥输入到服务器的 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; ，以便让我们不输入密码就可以登录服务器。当然你写代码的时候还可以用它来键入代码片段，不过它和 vscode 兼容性有点不好，有时会输入不想要的字符。我建议代码片段功能就用编辑器或 IDE 自带的，功能更加丰富点。&lt;/p&gt;
&lt;h2 id=&#34;推荐系统快捷键&#34;&gt;推荐系统快捷键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;系统偏好设置-键盘-修饰键&lt;/code&gt; 把 &lt;code&gt;大写锁定键&lt;/code&gt; 映射为 &lt;code&gt;Control&lt;/code&gt; 键，因为 ctrl 用的实在太频繁了，自带的键盘和其它普通的键盘的 ctrl 键位不好按，像 hhkb 这种键盘的 ctrl 键本身就在普通键盘的大写锁定键位置，所以就不用映射。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;系统偏好设置-键盘-调度中心&lt;/code&gt;，将 &lt;code&gt;向左移动一个空间&lt;/code&gt; 快捷键绑定为 &lt;code&gt;ctrl+,&lt;/code&gt;，&lt;code&gt;向右移动一个空间&lt;/code&gt; 快捷键绑定为 &lt;code&gt;ctrl+.&lt;/code&gt;。这样多个桌面空间之间的切换也很方便了，快捷键也不会跟其它软件冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，我还录了一个视频供大家参考学习：&lt;/p&gt;
&lt;p&gt;&lt;embed src=&#34;https://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&amp;v=20161117&amp;vid=f075714x4s9&amp;auto=0&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; width=&#34;900&#34; height=&#34;700&#34; align=&#34;middle&#34; allowScriptAccess=&#34;always&#34; type=&#34;application/x-shockwave-flash&#34;&gt;&lt;/embed&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
