<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>istio on roc</title>
    <link>https://imroc.io/tags/istio/</link>
    <description>Recent content in istio on roc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>roc@imroc.io (roc)</managingEditor>
    <webMaster>roc@imroc.io (roc)</webMaster>
    <lastBuildDate>Sun, 07 Apr 2019 11:54:00 +0800</lastBuildDate>
    
	<atom:link href="https://imroc.io/tags/istio/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Istio 学习笔记：Istio CNI 插件</title>
      <link>https://imroc.io/posts/istio-cni/</link>
      <pubDate>Sun, 07 Apr 2019 11:54:00 +0800</pubDate>
      <author>roc@imroc.io (roc)</author>
      <guid>https://imroc.io/posts/istio-cni/</guid>
      <description>设计目标 当前实现将用户 pod 流量转发到 proxy 的默认方式是使用 privileged 权限的 istio-init 这个 init container 来做的（运行脚本写入 iptables），Istio CNI 插件的主要设计目标是消除这个 privileged 权限的 init container，换成利用 k8s CNI 机制来实现相同功能的替代方案 原理 Istio CNI Plugin 不是 istio 提出类似 k8s CNI 的插件扩展机制，而是 k8s CNI 的一个具体实现 k8s CNI 插件是一条链，在创建和销毁pod的时候会调用链上所有插件来安装和卸载容器的网络，istio CNI Plugin 即为 CNI 插件的一个实现，相当于在创建销毁pod这些hook点来针对istio的pod做网络配置：写入iptables，让该 pod 所在的 network namespace 的网络流量转发到 proxy 进程 当然也就要求集群启用 CNI，kubelet 启动参数: --network-plugin=cni （该参数只有两个可选项：kubenet, cni） 实现方式 运行一个名为 istio-cni-node 的 daemonset 运行在每个节点，用于安装 istio CNI 插件 该 CNI 插件负责写入 iptables 规则，让用户 pod 所在 netns 的流量都转发到这个 pod 中 proxy 的进程 当启用 istio cni 后，sidecar 的自动注入或istioctl kube-inject将不再注入 initContainers (istio-init) istio-cni-node 工作流程 复制 Istio CNI 插件二进制程序到CNI的bin目录（即kubelet启动参数--cni-bin-dir指定的路径，默认是/opt/cni/b</description>
    </item>
    
  </channel>
</rss>